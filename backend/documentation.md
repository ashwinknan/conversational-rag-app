---
layout:
  title:
    visible: true
  description:
    visible: true
  tableOfContents:
    visible: true
  outline:
    visible: true
  pagination:
    visible: true
---

# Home

<figure><img src=".gitbook/assets/letsterra_cover (1).jpg" alt=""><figcaption></figcaption></figure>

## Welcome to the Terra Studio Wiki

Terra Studio is committed to transforming imagination into reality. This Wiki serves as your comprehensive guide, containing all the essential information you need. Whether you have questions or require assistance, you're in the right place.

Make sure to bookmark this page, as we will regularly update it with the latest additions to the studio.&#x20;

## What is Terra Studio?

Terra Studio is a **revolutionary new-age 3D game engine** aiming to empower a new generation of game creators. Designed to accelerate the game development process, making it **10 times faster** than traditional methods, Terra Studio enables game creators to bring their wildest game ideas to life without the steep learning curve associated with coding.

Terra Studio helps developers create top-quality games quickly by focusing on creativity and design.

## What you can do?

<table data-view="cards"><thead><tr><th></th><th data-hidden data-card-cover data-type="files"></th><th data-hidden data-card-target data-type="content-ref"></th></tr></thead><tbody><tr><td>Create no code games</td><td><a href=".gitbook/assets/Screenshot 2024-03-14 160524.png">Screenshot 2024-03-14 160524.png</a></td><td><a href="overview/getting-started.md#create-your-new-game">#create-your-new-game</a></td></tr><tr><td>Add pre-made assets to the game scene</td><td><a href=".gitbook/assets/asset.png">asset.png</a></td><td><a href="broken-reference">Broken link</a></td></tr><tr><td>Add Behaviours to your assets</td><td><a href=".gitbook/assets/behavior.png">behavior.png</a></td><td><a href="broken-reference">Broken link</a></td></tr><tr><td>Upgrade player or object properties using level upgrader</td><td><a href=".gitbook/assets/level up.png">level up.png</a></td><td><a href="broken-reference">Broken link</a></td></tr><tr><td>Publish games on the Terra Kids App</td><td><a href=".gitbook/assets/PUBLISH GAME.png">PUBLISH GAME.png</a></td><td><a href="editor-essentials/main-toolbar.md#publish">#publish</a></td></tr><tr><td>Create remixes</td><td><a href=".gitbook/assets/remix.png">remix.png</a></td><td><a href="overview/getting-started.md#remix">#remix</a></td></tr></tbody></table>

## Join Our Community

If you have any questions that our wiki couldn't answer, feel free to join our official Discord server! Our team and community are eager to help you. Click [here](https://discord.com/invite/nFmUq4Tf) to join.

<figure><img src=".gitbook/assets/image (6).png" alt=""><figcaption></figcaption></figure>

Even if you're not actively looking for answers, you're more than welcome to join our Discord community. We regularly share updates to help you stay ahead in your game.

# Table of contents

* [Home](README.md)

## OVERVIEW

* [Getting Started](overview/getting-started.md)
* [How do I download & install Terra Studio?](overview/how-do-i-download-and-install-terra-studio.md)

## Editor Essentials

* [Dashboard](editor-essentials/dashboard.md)
* [Scene Editor View](editor-essentials/scene-editor-view.md)
* [Builder Menu & Builder Panel](editor-essentials/builder-menu-and-builder-panel/README.md)
  * [Layers](editor-essentials/builder-menu-and-builder-panel/layers.md)
  * [Essentials](editor-essentials/builder-menu-and-builder-panel/essentials/README.md)
    * [Global Render Setting](editor-essentials/builder-menu-and-builder-panel/essentials/global-render-setting.md)
    * [Level Mapper](editor-essentials/builder-menu-and-builder-panel/essentials/level-mapper.md)
    * [In Game Timer](editor-essentials/builder-menu-and-builder-panel/essentials/in-game-timer.md)
  * [Scenes](editor-essentials/builder-menu-and-builder-panel/scenes.md)
* [Camera Controls](editor-essentials/camera-controls.md)
* [Main Toolbar](editor-essentials/main-toolbar.md)
* [Inspector Panel](editor-essentials/inspector-panel.md)
* [Important Keyboard Shortcuts](editor-essentials/important-keyboard-shortcuts.md)

## Coding Using T\#

* [T# Basics](coding-using-t/t-basics.md)
* [T# Don'ts](coding-using-t/t-donts.md)
* [T# Logic Template Wrappers](coding-using-t/t-logic-template-wrappers.md)
* [T# StudioController Wrappers](coding-using-t/t-studiocontroller-wrappers.md)
* [T# Haptics & Extensions](coding-using-t/t-haptics-and-extensions.md)

## CONCEPTUAL GUIDES

* [Building Blocks of a Terra Game](conceptual-guides/building-blocks-of-a-terra-game.md)
* [Configuring the Player](conceptual-guides/configuring-the-player.md)
* [Configuring the Game Scene](conceptual-guides/configuring-the-game-scene.md)
* [Configuring Game Logic](conceptual-guides/configuring-game-logic.md)
* [Setting up Game Systems](conceptual-guides/setting-up-game-systems.md)

## LOGIC TEMPLATES

* [Overall Game](logic-templates/overall-game/README.md)
  * [Checkpoint](logic-templates/overall-game/checkpoint.md)
  * [Update Timer](logic-templates/overall-game/update-timer.md)
  * [Reset Timer](logic-templates/overall-game/reset-timer.md)
  * [Load Scene](logic-templates/overall-game/load-scene.md)
  * [Random Level Selector](logic-templates/overall-game/random-level-selector.md)
  * [Studio Machine](logic-templates/overall-game/studio-machine.md)
* [Mechanics](logic-templates/mechanics/README.md)
  * [Collectable](logic-templates/mechanics/collectable.md)
  * [Teleport Player](logic-templates/mechanics/teleport-player.md)
  * [Jump Pad](logic-templates/mechanics/jump-pad.md)
  * [Carryable](logic-templates/mechanics/carryable.md)
  * [Deposit](logic-templates/mechanics/deposit.md)
  * [Kill Player](logic-templates/mechanics/kill-player.md)
  * [Multi-Point Move](logic-templates/mechanics/multi-point-move.md)
  * [Modify Carryable](logic-templates/mechanics/modify-carryable.md)
  * [Hinge Joint](logic-templates/mechanics/hinge-joint.md)
  * [Explosive Force](logic-templates/mechanics/explosive-force.md)
  * [Add Force](logic-templates/mechanics/add-force.md)
  * [Treadmill](logic-templates/mechanics/treadmill.md)
  * [Attach Object](logic-templates/mechanics/attach-object.md)
* [Actions](logic-templates/actions/README.md)
  * [Destroy](logic-templates/actions/destroy.md)
  * [Set Position](logic-templates/actions/set-position.md)
  * [Advance Instantiate](logic-templates/actions/advance-instantiate.md)
  * [Grow / Shrink](logic-templates/actions/grow-shrink.md)
  * [Move](logic-templates/actions/move.md)
  * [Rotate](logic-templates/actions/rotate.md)
  * [Move To Player](logic-templates/actions/move-to-player.md)
  * [Rotate Oscillate](logic-templates/actions/rotate-oscillate.md)
  * [Basic Instantiate](logic-templates/actions/basic-instantiate.md)
  * [Bump](logic-templates/actions/bump.md)
* [Conditionals](logic-templates/conditionals/README.md)
  * [Switch](logic-templates/conditionals/switch.md)
  * [OR Gate](logic-templates/conditionals/or-gate.md)
  * [AND Gate](logic-templates/conditionals/and-gate.md)
  * [Tick](logic-templates/conditionals/tick.md)
* [Triggers](logic-templates/triggers/README.md)
  * [Collide](logic-templates/triggers/collide.md)
  * [Click](logic-templates/triggers/click.md)
  * [Delay](logic-templates/triggers/delay.md)
* [Effects](logic-templates/effects/README.md)
  * [Stop Rotate](logic-templates/effects/stop-rotate.md)
  * [Stop Animation](logic-templates/effects/stop-animation.md)
  * [Play Player's Animation](logic-templates/effects/play-players-animation.md)
  * [ShowUI](logic-templates/effects/showui/README.md)
    * [ShowUI Prefabs](logic-templates/effects/showui/showui-prefabs.md)
    * [Show UI Icons](logic-templates/effects/showui/show-ui-icons.md)
* [PlayerStats](logic-templates/playerstats/README.md)
  * [Decrease Player HP](logic-templates/playerstats/decrease-player-hp.md)
  * [Increase Player HP](logic-templates/playerstats/increase-player-hp.md)
  * [Reset Player Health](logic-templates/playerstats/reset-player-health.md)
  * [Reset Score](logic-templates/playerstats/reset-score.md)
  * [Stop Player movement](logic-templates/playerstats/stop-player-movement.md)
  * [Update Magnet](logic-templates/playerstats/update-magnet.md)
  * [Level Up](logic-templates/playerstats/level-up.md)
  * [Update Score](logic-templates/playerstats/update-score.md)
  * [Change Player Speed](logic-templates/playerstats/change-player-speed.md)
* [Simulator Templates](logic-templates/simulator-templates/README.md)
  * [Cash Counter](logic-templates/simulator-templates/cash-counter.md)
  * [Convertible](logic-templates/simulator-templates/convertible.md)
  * [Output/Generator](logic-templates/simulator-templates/output-generator.md)
  * [Self-service customer](logic-templates/simulator-templates/self-service-customer.md)
  * [Helper](logic-templates/simulator-templates/helper.md)
  * [Storage/input](logic-templates/simulator-templates/storage-input.md)

# Conditionals

<table><thead><tr><th width="262">Logic Template</th><th>Description</th></tr></thead><tbody><tr><td><a href="switch.md">Switch</a></td><td></td></tr><tr><td><a href="or-gate.md">Or Gate</a></td><td>Acts as a gate that sends out a broadcast signal only after any one of the  required conditions are met. These conditions are broadcast signals from various sources. </td></tr><tr><td><a href="and-gate.md">And Gate</a></td><td>Acts as a gate that sends out a broadcast signal only after all required conditions are met. These conditions are broadcast signals from various sources. It won't activate until every condition is satisfied.</td></tr><tr><td><a href="tick.md">Tick</a></td><td>Generates a broadcast at a pre-defined time or time-intervals</td></tr><tr><td>Random Broadcast</td><td>Generates a broadcast randomly from a pre-specified list of broadcasts</td></tr></tbody></table>

# Tick

Applying Tick logic template to an asset allows you to attach a custom timer, whose start and stop can be controlled. This logic template can be used as a starting event for other logic templates

To add the Tick logic template to an asset, follow these steps:

1. Go to the Logic Tab.
2. Select Tick under the header "Conditionals".
3. Drag and drop it onto the desired asset.

You can edit the following parameters of this template directly through the scene editor interface:\


<table><thead><tr><th width="216">Parameters</th><th>Description</th></tr></thead><tbody><tr><td>Tick When</td><td><p>You can choose the start event for the object's timer from this dropdown:</p><ul><li>Game Start</li><li>Broadcast Received: When the object receives a broadcast message.</li></ul><p><br></p></td></tr><tr><td>Stop When</td><td>You can choose which broadcast will stop the execution when listened to.</td></tr><tr><td>Resume When</td><td>You can choose which broadcast will resume the execution when listened to.</td></tr><tr><td>Special Broadcasts</td><td><p>You can specify time intervals for the template to run and generate a broadcast. The available fields are:</p><ul><li><strong>When</strong>: Select "At" or "Every".</li><li><strong>In</strong>: Specify the time interval for the broadcast.</li><li><strong>Broadcast</strong>: Define the broadcast to be generated.</li></ul></td></tr></tbody></table>

### Accessing the Tick Logic Template using T\#

If you want to further customize this logic template, you can do so by accessing its T# Wrapper -  [TickTemplate](../../coding-using-t/t-logic-template-wrappers.md#ticktemplate)

# AND Gate

The **AND** operator is used when you want an event to occur only after a specific number of other events have taken place. When broadcasts are received from all the events specified in the **AND** operator behavior, another broadcast is triggered.

For example, the player only wins the game if they complete both of the game's checkpoints. When the player reaches each checkpoint, a broadcast is sent to the behaviour. Once the behavior receives both broadcasts, the game will end.

To add the AND Gate logic template to an asset, follow these steps:

1. Go to the Logic Tab.
2. Select AND Gate under the header "Conditionals".
3. Drag and drop it onto the desired asset.

You can edit the following parameters of this template directly through the scene editor interface:

<table><thead><tr><th width="282">Parameter</th><th>Description</th></tr></thead><tbody><tr><td>Wait For (Listen for)</td><td>Choose the broadcasts which are prerequisite for the operator to do further tasks. You can choose broadcasts from the selection menu. </td></tr><tr><td>Broadcast Data</td><td>Choose to enter a broadcast that can be used as a trigger for any other behavior. <br>The broadcast is sent when the behaviour has received all broadcasts.</td></tr><tr><td></td><td></td></tr></tbody></table>

### Accessing the AND Gate Logic Template using T\#

You can directly use conditionals in T# and do not need a wrapper to access thie logic template


# OR Gate

The Or Operator is used when you want an event to occur when either one of the defined events has taken place. When broadcasts are received from any event indicated in the Or Operator behavior, the behaviour will perform a particular action.

Example: When the player completes either of the two checkpoints and the operator receives a broadcast message from either of them, the next event scheduled by the behavour is triggered.

To add the OR Gate logic template to an asset, follow these steps:

1. Go to the Logic Tab.
2. Select OR Gate under the header "Conditionals".
3. Drag and drop it onto the desired asset.

You can edit the following parameters of this template directly through the scene editor interface:

<table><thead><tr><th width="282">Parameter</th><th>Description</th></tr></thead><tbody><tr><td>Wait For (Listen for)</td><td>Choose the broadcasts which are prerequisite for the operator to do further tasks. You can choose broadcasts from the selection menu. </td></tr><tr><td>Broadcast Data</td><td>Choose to enter a broadcast that can be used as a trigger for any other behavior. <br>The broadcast is sent when the behaviour has received all broadcasts.</td></tr></tbody></table>

### Accessing the OR Gate Template using T\#

You can directly use conditionals in T# and do not need a wrapper to access thie logic template


# Switch

The Switch logic template enables you to regulate the behaviors of an asset, whether it's the one you're interacting with or a different one. You can transmit broadcasts to activate or deactivate behaviors depending on the triggers associated with each action.&#x20;

For instance, suppose a cube possesses a switch logic template. In that case, when the player collides with the cube, an 'on-broadcast' signal is dispatched to the laser, prompting its rotation. Conversely, clicking on the cube sends an 'off-broadcast' signal to the laser, ceasing its rotation.

To add the Switch logic template to an asset, follow these steps:

1. Go to the Logic Tab.
2. Select Switch under the header "Conditionals".
3. Drag and drop it onto the desired asset.

You can edit the following parameters of this template directly through the scene editor interface:

<table><thead><tr><th width="313">Parameters</th><th>Description</th></tr></thead><tbody><tr><td>Switch On</td><td><p>You can choose the trigger that will turn "on" the switch:</p><p>- When a different object touches the object<br>- After a broadcast message has been received by the object</p><p>-When the player exits.<br>- When the player collides with the object.<br>- When the object is clicked </p></td></tr><tr><td>Sound Effect When On</td><td>Choose a sound effect to play when the switch is turned "on"</td></tr><tr><td>Visual Effect When On</td><td>Choose a visual effect to play when the switch is turned "on"</td></tr><tr><td>Broadcast After On</td><td>Choose to enter a broadcast that can be used as a trigger for any other behavior. <br>The broadcast is sent when switch is turned "on"</td></tr><tr><td>Switch Off</td><td><p>You can choose the trigger that will turn "off" the switch:</p><p>- When a different object touches the object<br>- After a broadcast message has been received by the object</p><p>-When the player exits.<br>- When the player collides with the object<br>- When the object is clicked</p></td></tr><tr><td>Sound Effect When Off</td><td>Choose a sound effect to play when the switch is turned "off"</td></tr><tr><td>Visual Effect When Off</td><td>Choose a visual effect to play when the switch is turned "off"</td></tr><tr><td>Broadcast After Off</td><td>Choose to enter a broadcast that can be used as a trigger for any other behavior. <br>The broadcast is sent when switch is turned "off"</td></tr></tbody></table>

### Accessing the Switch Logic Template using T\#

If you want to further customize this logic template, you can do so by accessing its T# Wrapper -  [SwitchTemplate](../../coding-using-t/t-logic-template-wrappers.md#switchtemplate)


# Triggers

<table><thead><tr><th width="262">Logic Template</th><th>Description</th></tr></thead><tbody><tr><td><a href="collide.md">Collide</a></td><td>Uses contact of collider of the player as a trigger and allows you to generate a broadcast</td></tr><tr><td><a href="click.md">Click</a></td><td>Uses mouse click as a trigger and allows you to generate broadcast</td></tr><tr><td><a href="delay.md">Delay</a></td><td>Introduces a delay of a specified time</td></tr></tbody></table>

# Delay

The Delay logic template allows you to add a few seconds of delay in between the broadcasts which eventually creates a gap of a few seconds between two different events. Usually, events happen instantly as soon as they receive the broadcast but with the help of a delay behavior, you can add a delay between two events.

To add the Delay logic template to an asset, follow these steps:

1. Go to the Logic Tab.
2. Select Delay under the header "Triggers".
3. Drag and drop it onto the desired asset.

You can edit the following parameters of this template directly through the scene editor interface:

<table><thead><tr><th width="279">Parameters</th><th>Description</th></tr></thead><tbody><tr><td>Listen To</td><td>Choose a broadcast from the drop drop menu. Once the object receives this broadcast, there will be a delay created for the next event.</td></tr><tr><td>Delay Time</td><td>Define the seconds by how long there will be a delay</td></tr><tr><td>Broadcast</td><td>Choose to enter a broadcast that can be used as a trigger for any other behavior. <br>The broadcast is sent after the defined delay time has completed.</td></tr></tbody></table>

### Accessing the Delay Logic Template using T\#

If you want to further customize this logic template, you can do so by accessing its T# Wrapper -  [DelayBroadcastTemplate](../../coding-using-t/t-logic-template-wrappers.md#delaybroadcasttemplate)


# Collide

Any object with the Collide logic template attached sends a broadcast either when you collide with it or when a different object touches it.

To add the Collide logic template to an asset, follow these steps:

1. Go to the Logic Tab.
2. Select Collide under the header "Triggers".
3. Drag and drop it onto the desired asset.

You can edit the following parameters of this template directly through the scene editor:

<table><thead><tr><th width="259">Parameters</th><th>Description</th></tr></thead><tbody><tr><td>Start On</td><td>Choose how to collide. You have OnPlayerCollide or OtherObjectTouches</td></tr><tr><td>Play SFX</td><td>Choose a sound effect to play when you collide with the object.</td></tr><tr><td>Play VFX</td><td>Choose a visual effect to play when you collide with the object.</td></tr><tr><td>BroadcastData</td><td>Choose to enter a broadcast that can be used as a trigger for any other behavior. <br>The broadcast is sent when you collide with the object.</td></tr></tbody></table>

# Click

The Click logic template enables you to send a broadcast when you click on an asset.&#x20;

To add the Click logic template to an asset, follow these steps:

1. Go to the Logic Tab.
2. Select Click under the header "Triggers".
3. Drag and drop it onto the desired asset.

You can edit the following parameters of this template directly through the scene editor interface:

| Parameter      | Description                                                                                                                                     |
| -------------- | ----------------------------------------------------------------------------------------------------------------------------------------------- |
| Play SFX       | Choose a sound effect to play when you click on the asset                                                                                       |
| Play  VFX      | Choose a visual effect to play when you click on the asset                                                                                      |
| Broadcast Data | <p>Choose to enter a broadcast that can be used as a trigger for any other behavior. <br>The broadcast is sent when you click on the asset.</p> |


# PlayerStats

<table><thead><tr><th width="262">Logic Template</th><th>Description</th></tr></thead><tbody><tr><td><a href="update-score.md">Update Score</a></td><td>Updates a specific score group to a new specified value</td></tr><tr><td><a href="reset-score.md">Reset Score</a></td><td>Resets the specified score group to zero</td></tr><tr><td><a href="increase-player-hp.md">Increase HP</a></td><td>Increases the player Health value by the specific amount</td></tr><tr><td><a href="decrease-player-hp.md">Damage HP</a></td><td>Decreases the player Health value by a specific amount</td></tr><tr><td><a href="reset-player-health.md">Reset Health</a></td><td>Resets the player Health value to zero</td></tr><tr><td><a href="level-up.md">Level Up</a></td><td>Guides the Level Mapper on how to increase a property's level to the next tier.</td></tr><tr><td><a href="update-magnet.md">Change Magnet Range</a></td><td>Changes the magnet range for the player's collection</td></tr><tr><td><a href="stop-player-movement.md">Toggle Player Movement</a></td><td>Stops or starts the player movements</td></tr><tr><td>Change Player Speed</td><td>Changes the speed of movement of the player</td></tr></tbody></table>

# Change Player Speed

Applying the Change Player Speed template changes the speed of the player to the desired value.&#x20;

To add the Change Player Speed logic template to an asset, follow these steps:

1. Go to the Logic Tab.
2. Select Change Player Speed under the header "PlayerStats".
3. Drag and drop it onto the desired asset.

You can edit the following parameters of this template directly through the scene editor:

<table><thead><tr><th width="202">Parameter</th><th>Description</th></tr></thead><tbody><tr><td>Change On When</td><td><p></p><p>Define the trigger for changing the speed. The four available triggers are:</p><ul><li><strong>Player Touches</strong></li><li><strong>Other Object Touches</strong></li><li><strong>Clicked</strong></li><li><strong>Broadcast Listened</strong></li></ul></td></tr><tr><td>Modifier</td><td>Define the modifier: <br>1. Set - Set to a defined value <br>2. Multiply - Multiply by the given value<br>3. Add - Increase by the given value<br>4. Subtract - Subtract the given value<br>5. Divide - Divide by the given value</td></tr><tr><td>Speed </td><td>Specify the value to apply the modifier to the current speed</td></tr><tr><td>SFX / VFX</td><td>Specify the SFX and VFX to be played upon execution</td></tr><tr><td>Broadcast</td><td>Define any broadcast for another object to listen to</td></tr></tbody></table>

### Accessing the Change Player Speed Logic Template using T\#

If you want to further customize this logic template, you can do so by accessing its T# Wrapper -  [ChangePlayerSpeedTemplate](../../coding-using-t/t-logic-template-wrappers.md#changeplayerspeedtemplate)

# Update Magnet

The Update Magnet behavior increases the player's magnetic range, allowing them to collect items from a larger radius compared to the initial specified range.

To add the Update Magnet logic template to an asset, follow these steps:

1. Go to the Logic Tab.
2. Select Update Magnet under the header "PlayerStats".
3. Drag and drop it onto the desired asset.

You can edit the following parameters of this template directly through the scene editor:

| Parameter          | Description                                                                                                                                                                                                                                                                              |
| ------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Change Magnet When | <p>Define the action that will trigger a change in the magnetic field. The actions could be:<br>- After a broadcast message received by the object.<br>- When the player touches the object.<br>- When a different object touches the object.<br>- When you click on the object.<br></p> |
| Radius             | The amount defined will act as the updated radius                                                                                                                                                                                                                                        |
| Play SFX           | Choose a sound effect to play when the magnet range is updated                                                                                                                                                                                                                           |
| Play VFX           | Choose a visual effect to play when the magnet range is updated                                                                                                                                                                                                                          |
| Broadcast Data     | <p>Define a broadcast that can be used as a trigger for any other behavior. <br>The broadcast is sent when the magnetic range is updated</p>                                                                                                                                             |

### Accessing the Update Magnet Animation Logic Template using T\#

If you want to further customize this logic template, you can do so by accessing its T# Wrapper - [ChangeMagnetTemplate](../../coding-using-t/t-logic-template-wrappers.md#changemagnettemplate)

# Increase Player HP

When triggered, the Increase Player HP logic template  boosts the player's health. The behavior can be activated in response to various events, such as the player collecting coins or other items that improve health.&#x20;

To add the Increase Player HP logic template to an asset, follow these steps:

1. Go to the Logic Tab.
2. Select Increase Player HP under the header "PlayerStats".
3. Drag and drop it onto the desired asset.

You can edit the following parameters of this template directly through the scene editor:

<table><thead><tr><th width="276">Parameters</th><th>Description</th></tr></thead><tbody><tr><td>When</td><td>You can choose the trigger to activate the behaviour<br>- After a broadcast message has been received by the object<br>- When the player touches the object</td></tr><tr><td>By Point</td><td>The player's health will increase by the defined amount when the behaviour is triggered.</td></tr><tr><td>Play SFX</td><td>Choose a sound effect to play when the health increases.</td></tr><tr><td>Play VFX</td><td>Choose a visual effect to play when the health increases.</td></tr><tr><td>Broadcast</td><td>Choose to enter a broadcast that can be used as a trigger for any other behavior. <br>The broadcast is sent everytime the player health increases.</td></tr></tbody></table>

### Accessing the Increase Player HP Logic Template using T\#

There are currently no available T# Wrappers for this template.&#x20;


# Level Up

Level up behaviour is used to upgrade different in-game assets based on the the upgrade paths of objects defined using the [Level Mapper](../../conceptual-guides/setting-up-game-systems.md) game system.

To add the Level Mapper logic template to an asset, follow these steps:

1. Go to the Logic Tab.
2. Select Level Mapper under the header "PlayerStats".
3. Drag and drop it onto the desired asset.

You can edit the following parameters of this template directly through the scene editor:

<table><thead><tr><th width="239">Parameter</th><th>Description</th></tr></thead><tbody><tr><td>Level up when</td><td>You can choose the trigger to activate the behaviour <br>- After a broadcast message has been received by the object<br>- When the player touches the object<br>- When a different object touches the object<br>- When you click on the object</td></tr><tr><td>Sound Effect on Start</td><td>Choose a sound effect to play on execution</td></tr><tr><td>Visual Effect on Start</td><td>Choose a visual effect to play on execution</td></tr><tr><td>Manager group</td><td>Helps to choose the score group based on which the Level up will be decided</td></tr><tr><td>Broadcast Success</td><td>Define a broadcast to be generated when the level up is successful</td></tr><tr><td>Broadcast Fails </td><td>Define the broadcast to be generated when the level up fails</td></tr><tr><td>Execute Times</td><td>Number of times behaviour need to be excuted </td></tr></tbody></table>

### Accessing the Level Up Logic Template using T\#

There are currently no available T# Wrappers for this template.&#x20;

# Decrease Player HP

In games, lowering the player's health as a result of certain interactions is a common mechanic. The Decrease Player HP Logic template reduces the player's health when specific triggers are activated.

To add the Decrease Player HP logic template to an asset, follow these steps:

1. Go to the Logic Tab.
2. Select Decrease Player HP under the header "PlayerStats".
3. Drag and drop it onto the desired asset.

You can edit the following parameters of this template directly through the scene editor:

<table><thead><tr><th width="291">Parameters</th><th>Description</th></tr></thead><tbody><tr><td>When</td><td>You can choose the trigger to activate the behaviour.<br>- After a broadcast message has been received by the object.<br>- When the player touches the object.</td></tr><tr><td>By Point</td><td>The player's health will decrease by the defined amount when the behaviour is triggered.</td></tr><tr><td>Play SFX</td><td>Choose a sound effect to play when the health decreases.</td></tr><tr><td>Play VFX</td><td>Choose a visual effect to play when the health decreases.</td></tr><tr><td>Broadcast</td><td>Choose to enter a broadcast that can be used as a trigger for any other behavior. <br>The broadcast is sent everytime the player health decreases.</td></tr></tbody></table>

### Accessing the Decrease Player HP Logic Template using T\#

There are currently no available T# Wrappers for this template.&#x20;


# Reset Player Health

When a player interacts with an object tagged with the Reset Player Health logic template, the player's health is fully restored. This can be useful when a player respawns after dying, enters a safe zone, collects healing items, or faces similar situations.

To add the Reset Player Health logic template to an asset, follow these steps:

1. Go to the Logic Tab.
2. Select Reset Player Health under the header "PlayerStats".
3. Drag and drop it onto the desired asset.

You can edit the following parameters of this template directly through the scene editor:

<table><thead><tr><th width="276">Parameters</th><th>Description</th></tr></thead><tbody><tr><td>When</td><td>You can choose the trigger to activate the behaviour.<br>- After a broadcast message has been received by the object.<br>- When the player touches the object.<br>- When the object is clicked.</td></tr><tr><td>Play SFX</td><td>Choose a sound effect to play when the health is reset</td></tr><tr><td>Play VFX</td><td>Choose a visual effect to play when the health is reset</td></tr><tr><td>Broadcast</td><td>Choose to enter a broadcast that can be used as a trigger for any other behavior. <br>The broadcast is sent when health is restored.</td></tr></tbody></table>

### Accessing the Reset Player Health Logic Template using T\#

There are currently no available T# Wrappers for this template.&#x20;

# Stop Player movement

When a player comes into contact with an asset that has the StopPlayerMovement logic template applied, the player's motion in the game environment is halted. This logic template locks the player in their current position and deactivates any movement through the controller.

To add the Stop Player Movement logic template to an asset, follow these steps:

1. Go to the Logic Tab.
2. Select Stop Player Movement under the header "PlayerStats".
3. Drag and drop it onto the desired asset.

You can edit the following parameters of this template directly through the scene editor:

<table><thead><tr><th width="246">Parameters</th><th>Description</th></tr></thead><tbody><tr><td>Start When</td><td><p>You can choose the trigger to activate the behaviour </p><p>- When the game starts<br>- After a broadcast message has been received by the object.<br>- When the player touches the object.<br>- When a different object touches the object.<br>- When you click on the object.</p></td></tr><tr><td>Play SFX</td><td>Choose a sound effect to play when the player stops moving.</td></tr><tr><td>Play VFX</td><td>Choose a visual effect to play when the player stops moving.</td></tr><tr><td>Broadcast</td><td>Choose to enter a broadcast that can be used as a trigger for any other behavior. <br>The broadcast is sent when the player stops moving again.</td></tr></tbody></table>



### Accessing the Stop Player Movement Logic Template using T\#

There are currently no available T# Wrappers for this template.&#x20;

# Update Score

You may want to enhance the gameplay experience by adjusting the game [score ](../../conceptual-guides/setting-up-game-systems.md#score)when specific conditions are met. For instance:

* Update the score when the player collects items such as coins, gems, or power-ups. This promotes exploration and rewards the player's curiosity.
* Increase the score upon completing a level or reaching a milestone, such as finishing a race track or solving a puzzle.
* Award points for unique or challenging achievements outside the normal gameplay loop, such as discovering hidden areas.

To add the Update Score logic template to an asset, follow these steps:

1. Go to the Logic Tab.
2. Select Update Score under the header "PlayerStats".
3. Drag and drop it onto the desired asset.

You can edit the following parameters of this template directly through the scene editor:

<table><thead><tr><th width="202">Parameter</th><th>Description</th></tr></thead><tbody><tr><td>Update When</td><td>Allows you to define the trigger for updating the score. There are four triggers allowed:<br>Player Touches- Updates the score when the player touches the selected object<br>Other Object Touches - Updates the score when another object touches the selected object<br>Clicked - Updates the score when you click the selected object<br>Broadcast Listened - Updates the score when it listens to a broadcast from another object</td></tr><tr><td>Score Group</td><td>Define which score group needs to be updated based on the trigger event happening</td></tr><tr><td>Operator </td><td>Define the operator to multiply by. Four operators are allowed - Add, Subtract, Multiply and Divide</td></tr><tr><td>Update By</td><td>Define an integer (positive or negative) to change the score by. For instance, if the operator is Add and Update By is given the value 10, then the score is increased by 10 every time the trigger event defined in Update When happens</td></tr><tr><td>Broadcast</td><td>Define any broadcast for another object to listen to</td></tr></tbody></table>

### Accessing the Update Score Logic Template using T\#

If you want to further customize this logic template, you can do so by accessing its T# Wrapper -  [UpdateScoreTemplate](../../coding-using-t/t-logic-template-wrappers.md#updatescoretemplate)

# Reset Score

You might want to enhance the gameplay experience by resetting the game score to zero when certain conditions are met during gameplay. For example, you may choose to reset the score when the player starts a new game or advances to a new level.

To add the Reset Score logic template to an asset, follow these steps:

1. Go to the Logic Tab.
2. Select Reset Score under the header "PlayerStats".
3. Drag and drop it onto the desired asset.

You can edit the following parameters of this template directly through the scene editor:

<table><thead><tr><th width="202">Parameter</th><th>Description</th></tr></thead><tbody><tr><td>Update When</td><td>Allows you to define the trigger for resetting the score. There are four triggers allowed:<br>Player Touches- Resets the score when the player touches the selected object<br>Other Object Touches - Resets the score when another object touches the selected object<br>Clicked - Resets the score when you click the selected object<br>Broadcast Listened - Resets the score when it listens to a broadcast from another object</td></tr><tr><td>Score Group</td><td>Define which score group needs to be reset based on the trigger event happening</td></tr><tr><td>Broadcast</td><td>Define any broadcast for another object to listen to</td></tr></tbody></table>

### Accessing the ResetScore Logic Template using T\#

If you want to further customize this logic template, you can do so by accessing its T# Wrapper -  [ResetScoreTemplate](../../coding-using-t/t-logic-template-wrappers.md#resetscoretemplate)


# Mechanics

<table><thead><tr><th width="255">Logic Template</th><th>Description</th></tr></thead><tbody><tr><td><a href="collectable.md">Collectable</a></td><td>Enables an object to be collected by the player and update the game score. Used in Power-ups. </td></tr><tr><td><a href="teleport-player.md">Teleport Player</a></td><td>Instantly spawns the Player in a new specified position</td></tr><tr><td><a href="jump-pad.md">Jump pad</a></td><td>Creates a jump enhancement for the player upon contact</td></tr><tr><td><a href="carryable.md">Carryable</a></td><td>Enables an Asset to be carried by the Player. The Asset will now move with the Player</td></tr><tr><td><a href="carryable.md">Deposit</a></td><td>Enables the Player to transfer the Carriable Asset and deposit it to a new Asset which is a storage</td></tr><tr><td><a href="modify-carryable.md">Modify Carryable</a></td><td>Modifies the number of carryables you have</td></tr><tr><td><a href="kill-player.md">Kill Player</a></td><td>Respawns the player to the start of the level</td></tr><tr><td><a href="hinge-joint.md">Hinge Joint</a></td><td>Enables assets to rotate about a defined hinge like a dore</td></tr><tr><td><a href="hinge-joint.md">Explosive Force</a></td><td>Applies a force / impulse on a radius</td></tr><tr><td><a href="add-force.md">Add Force</a></td><td>Applies a force on an object and allows it to follow physics </td></tr><tr><td><a href="treadmill.md">Treadmill</a></td><td>Enables treadmill-like motion on contact</td></tr><tr><td><a href="multi-point-move.md">Multi Point Move</a></td><td>Shifts the Asset from its starting spot through a path of straight or curved points as needed.</td></tr><tr><td><a href="attach-object.md">Attach Object</a></td><td>Parents an object to another object</td></tr></tbody></table>

# Jump Pad

The Jump Pad boosts the player's jump height when attached to an asset. Upon touching an object with the Jump Pad logic template, the player's jump is elevated. After the jump action, the jump height is restored to the initial value.

To add the Jump Pad logic template, follow these steps:

1. Go to the Logic Tab.
2. Select Jump Pad under the header "Mechanics".
3. Drag and drop it onto the desired asset.

You can customize the below-mentioned parameters according to your requirements:

| Parameters     | Description                                                                                                                                                                   |
| -------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Play SFX       | Choose a sound effect to play when the player jumps                                                                                                                           |
| Play VFX       | Choose a visual effect to play when the player jumps                                                                                                                          |
| Jump Force     | Define the multiplier by which the existing jump height will be multiplied for that instance                                                                                  |
| Broadcast Data | <p>Choose to enter a broadcast that can be used as a trigger for any other behavior. <br><code>The broadcast is sent when the player jumps at an increased height.</code></p> |

{% hint style="info" %}
Your Jump Height should ideally be greater than 2 for the Jump Pad to work. Small jump height values will not lead to an increased jump height. You can find Jump Height in the Player Controller Drawer. Eg: A jump Height of 0.1 with a Jump Force of 10 will change the total jump height to 0.01 which is lower than the initial height.
{% endhint %}

### Accessing the Jump Pad Template using T\#

If you want to further customize this logic template, you can do so by accessing its T# Wrapper - [JumpPadTemplate](../../coding-using-t/t-logic-template-wrappers.md#jumppadtemplate)

# Kill Player

When the player contacts an object with the Kill Player behavior, the player is killed and respawns at the last checkpoint. This is useful when the player enters a danger zone or interacts with a hazardous object.

To add the Kill Player logic template, follow these steps:

1. Go to the Logic Tab.
2. Select Kill Player under the header "Mechanics".
3. Drag and drop it onto the desired asset.

You can customize the below-mentioned parameters according to your requirements:

| Parameter                                               | Description                                                                                                                                   |
| ------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------- |
| <mark style="color:blue;">`Play SFX`</mark>             | Choose a short chime to play when the player is killed                                                                                        |
| <mark style="color:blue;">`Play VFX`</mark>             | Choose a small visual effect to play on the object when the player is killed                                                                  |
| <mark style="color:blue;">`Broadcast On Respawn`</mark> | <p>Choose to enter a broadcast that can be used as a trigger for any other behavior. <br>The broadcast is sent when the player is killed.</p> |

### Accessing the Kill Player Template using T\#

If you want to further customize this logic template, you can do so by accessing its T# Wrapper - [KillPlayerTemplate](../../coding-using-t/t-logic-template-wrappers.md#killplayertemplate)

# Add Force

The Add Force Logic Template allows you to apply a force on an asset and enable it to act according to the laws of physics.&#x20;

To add the Add Force logic template, follow these steps:

1. Go to the Logic Tab.
2. Select Add Force under the header "Mechanics".
3. Drag and drop it onto the desired asset.

You can edit the following parameters of this template directly through the scene editor interface:

| Parameter                                         | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| ------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| <mark style="color:blue;">`Add Force When`</mark> | <p>This is a dropdown from where you need select any one of the following Start Events for the template<br> <br>1. When any other Asset touches the currently selected Asset: Select "Other Object Touch"<br>2. When a particular broadcast is generated in the game: Select "Broadcast Listened" and specify the name of the signal to listen to<br>3. When the player touches the currently selected Asset: Select "Player Touchers"<br>4. When the Asset is clicked: Select "On Click" </p> |
| <mark style="color:blue;">`Force`</mark>          | Specify the value of the force to be applied                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| <mark style="color:blue;">`Repeat Mode`</mark>    | Dropdown to select the nature of repetition if any - Single, Repetitive, Periodic                                                                                                                                                                                                                                                                                                                                                                                                              |
| <mark style="color:blue;">`Period`</mark>         | If periodic, specify the period                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| <mark style="color:blue;">`Play SFX`</mark>       | Choose a short chime to play on execution                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| <mark style="color:blue;">`Play VFX`</mark>       | Choose a small visual effect to play on execution                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| <mark style="color:blue;">`Broadcast`</mark>      | <p>Choose to enter a broadcast that can be used as a trigger for any other behavior. <br>The broadcast is sent after execution</p>                                                                                                                                                                                                                                                                                                                                                             |

### Accessing the Add Force Template using T\#

Currently, there's no T# Wrapper available to customize this logic template beyond the scene editor's capabilities. However, you can write your own code in T# to implement this logic from scratch.


# Multi-Point Move

{% embed url="https://www.loom.com/share/23fb779803cd444d98f47df7d8fbebee?sid=1c587de4-6710-40e9-b0fb-a7fad42e52b4" %}
Interpolate Points&#x20;
{% endembed %}



Multi-Point Move is a logic template that allows you to instruct an Asset to follow a path made up of several points once its Start Event occurs. This path can be straight lines or curves between the points, giving you many choices for how the Asset moves.

The Asset can automatically turn to make sure a specific side always points towards the path, just like how our face turns to the direction we are moving.

To add the Multi-Point Move logic template, follow these steps:

1. Go to the Logic Tab.
2. Select Multi-Point Move under the header "Mechanics".
3. Drag and drop it onto the desired asset.

You can customize the below-mentioned parameters according to your requirements:

<table><thead><tr><th width="204">Parameter</th><th>Description</th></tr></thead><tbody><tr><td>Move On</td><td>This is a dropdown from where you need select any one of the following Start Events for Interpolate Points to begin executing: <br> <br>1. When the behavior  when the game starts: Select "Game Start"<br>2. When any other Asset touches the currently selected Asset: Select "Other Object Touch"<br>3. When a particular broadcast is generated in the game: Select "Broadcast Listened" and specify the name of the signal to listen to<br>4. When the player touches the currently selected Asset: Select "Player Touchers"<br>5. When the Asset is clicked: Select "On Click" </td></tr><tr><td>Points</td><td>This helps you specify the coordinates of the multiple points through which the Asset will move in a path. Click the + button to add points and - button to remove an existing point</td></tr><tr><td>Speed</td><td>This is an input field where you can enter a number that represents the speed of Asset movement</td></tr><tr><td>Turn To Points</td><td>This toggle button ensures that only one side of the Asset always faces forward. When activated, it adjusts the Asset's orientation to maintain this specific direction during movement.</td></tr><tr><td>Delay at Point</td><td>This field lets you set a delay in seconds. During this delay, the Asset will not move. After the time passes, it will start moving again.</td></tr><tr><td>Loop</td><td>This toggle button, when activated, enables the movement to repeat continuously</td></tr><tr><td>Is Curve</td><td>This toggle button alters the Asset's trajectory between points to follow a curved path instead of a linear one.</td></tr><tr><td>Interpolate Types</td><td><p></p><p>This dropdown lets you pick how the object moves:</p><ul><li>For forward movement only, select <strong>One Direction</strong></li><li>For back-and-forth movement, select <strong>Ping Pong</strong></li></ul></td></tr><tr><td>Broadcast Type &#x26; Broadcast Signal</td><td><p>The Broadcast Signal option allows you to create a game signal that other can act as the Start Event for other behavior blocks to execute. You can choose "Game Win", "Game Lose", or create your own custom signal. For a custom signal, you must select "Custom" from the dropdown and enter a name in the input field.<br><br>The Broadcast Type dropdown lets you specify when the broadcast signal will be sent. There are three options to choose from:</p><ul><li>If you want no broadcast to be sent, Select Never</li><li>If you want to send a broadcast after finishing one whole movement from start to end, select End </li><li>If you want to send the broadcast signal every time the object pauses , select At Every Pause</li></ul></td></tr></tbody></table>

### Accessing the Multi Point Move Template using T\#

If you want to further customize this logic template, you can do so by accessing its T# Wrapper- [MoveBetweenPointsTemplate ](../../coding-using-t/t-logic-template-wrappers.md#movebetweenpointstemplate)

# Explosive Force

The Explosive Force Logic Template allows the attached object to exert a sudden explosive force or impulse on nearby objects within a certain radius.

To add the Explosive Force logic template, follow these steps:

1. Go to the Logic Tab.
2. Select Explosive Force under the header "Mechanics".
3. Drag and drop it onto the desired asset.

You can edit the following parameters of this template directly through the scene editor interface:

| Parameter                                       | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| ----------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| <mark style="color:blue;">`Explode When`</mark> | <p>This is a dropdown from where you need select any one of the following Start Events for the template<br> <br>1. When any other Asset touches the currently selected Asset: Select "Other Object Touch"<br>2. When a particular broadcast is generated in the game: Select "Broadcast Listened" and specify the name of the signal to listen to<br>3. When the player touches the currently selected Asset: Select "Player Touchers"<br>4. When the Asset is clicked: Select "On Click" </p> |
| <mark style="color:blue;">`Force`</mark>        | Specify the value of the force to be applied                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| <mark style="color:blue;">`Radius`</mark>       | Specify the radius where the force is felt                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| <mark style="color:blue;">`Explode SFX`</mark>  | Choose a short chime to play on execution                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| <mark style="color:blue;">`Explode VFX`</mark>  | Choose a small visual effect to play on execution                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| <mark style="color:blue;">`Broadcast`</mark>    | <p>Choose to enter a broadcast that can be used as a trigger for any other behavior. <br>The broadcast is sent after execution</p>                                                                                                                                                                                                                                                                                                                                                             |

### Accessing the Explosive Template using T\#

Currently, there's no T# Wrapper available to customize this logic template beyond the scene editor's capabilities. However, you can write your own code in T# to implement this logic from scratch.


# Teleport Player

&#x20;The Teleport Player logic template can be used to teleport the player from one location to another in response to a specified trigger.

To add the Teleport Player logic template to an asset, follow these steps:

1. Go to the Logic Tab.
2. Select Teleport Player under the header "Mechanics".
3. Drag and drop it onto the desired asset.

{% embed url="https://www.loom.com/share/ef35d82e57cc4b218fb7ac9f1e50a084?sid=4346d208-40a5-4909-a0ff-cd6db2aa12f0" %}
Teleport Player Behaviour
{% endembed %}

You can customize the below-mentioned parameters according to your requirements:

<table><thead><tr><th width="239">Parameter</th><th>Description</th></tr></thead><tbody><tr><td>Teleport When</td><td><p>You can choose the trigger to activate the behaviour </p><p>- When the game starts<br>- After a broadcast message has been received by the object<br>- When the player touches the object<br>- When a different object touches the object<br>- When you click on the object</p></td></tr><tr><td>Teleport </td><td>You can choose the coordinates where you want the player to be teleported.</td></tr><tr><td>Loop-able</td><td>This allows you to loop the movement of the object. It appears as if it is oscillating between 2 different points.</td></tr><tr><td>Interval</td><td>Intervals add a delay between the back-and-forth movement of the object during the loop.</td></tr><tr><td>Move By</td><td>You can define how many units and in what axis the object will move</td></tr><tr><td>Sound Effect on Start</td><td>Choose a sound effect to play when the object starts to move</td></tr><tr><td>Visual Effect on Start</td><td>Choose a visual effect to play when the object starts to move</td></tr><tr><td>Broadcast </td><td>Choose to enter a broadcast that can be used as a trigger for any other behavior. <br>The broadcast is sent when the object stops moving..</td></tr></tbody></table>

### Accessing the Teleport Player Template using T\#

If you want to further customize this logic template, you can do so by accessing its T# Wrapper - [TeleportTemplate](../../coding-using-t/t-logic-template-wrappers.md#teleporttemplate)

# Collectable

A Collectible is a logic template added to an asset in a game that can be collected to increase score or to achieve another goal.

One or multiple triggers can be created, resulting in one or multiple outcomes.

To add the Collectable logic template, follow these steps:

1. Go to the Logic Tab.
2. Select Collectable under the header "Mechanics".
3. Drag and drop it onto the desired asset.

You can customize the below-mentioned parameters according to your requirements:

| Parameter               | Description                                                                                                                                                                                                           |
| ----------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Collect When            | <p></p><p>Choose when the item is collected:</p><ul><li>when player touches</li><li>when clicked on screen</li><li>when in a magnet range</li><li>When the player has to stay near it for a specific time</li></ul> |
| Sound Effect on Start   | Choose a short chime to play when item is collected                                                                                                                                                                   |
| Visual Effect on Start  | Choose a small visual effect to play when item is collected                                                                                                                                                           |
| Score Group             | The point of the Collectable will be contributed to the score group. You can either add it to Main Score group or make your own custom group                                                                          |
| Update Score By         | <p>Enter a numerical score value to update when collected.<br> Note: to reduce a score when collected, enter a negative value!</p>                                                                                   |
| IsMultiLevel            | Enabling this parameter can upgrade to a higher value on level up                                                                                                                                                     |
| Broadcast On Collection | <p>Choose to enter a broadcast that can be used as a trigger for any other behaviour.<br>The broadcast is sent when the item is collected</p>                                                                         |

### Accessing the Collectible Template using T\#

If you want to further customize this logic template, you can do so by accessing its T# Wrapper - [CollectableTemplate](../../coding-using-t/t-logic-template-wrappers.md#collectabletemplate)

# Deposit

The deposit logic template when applied to an asset, allows it to collect a specified carryable. The deposit logic template cannot work independently when there is no carryable in the scene

To add the Deposit logic template, follow these steps:

1. Go to the Logic Tab.
2. Select Deposit under the header "Mechanics".
3. Drag and drop it onto the desired asset.

{% embed url="https://www.loom.com/share/f67cf9873a584bebae54cf5c94e1ffda?sid=f7158aca-4596-4c1d-b54d-f1bd5877fddb" %}
Carriable and deposit
{% endembed %}

You can customize the below-mentioned parameters according to your requirements:

| Parameter              | Description                                                                                                                                                                                                                                                                 |
| ---------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Deposit when           | <p></p><p>Choose when the item is Deposited, using the dropdown:</p><ul><li>when player touches</li><li>when other object touches</li><li>when clicked on screen</li><li>when in a magnet range</li><li>When the player has to stay near it for a specific time</li></ul> |
| Take Resource          | select the group which wh                                                                                                                                                                                                                                                   |
| Persistent             | checking this box                                                                                                                                                                                                                                                           |
| Play SFX               | Choose a short chime to play when item is collected                                                                                                                                                                                                                         |
| Play VFX               | Choose a small visual effect to play when item is collected                                                                                                                                                                                                                 |
| Lerp                   |                                                                                                                                                                                                                                                                             |
| Lerp Time              |                                                                                                                                                                                                                                                                             |
| Cost type              |                                                                                                                                                                                                                                                                             |
| Size of carriable      |                                                                                                                                                                                                                                                                             |
| Score Group            | The point of the Collectable will be contributed to the score group. You can either add it to Main Score group or make your own custom group                                                                                                                                |
| Deposit rate           | You can set the rate at which the carriable will get deposited.                                                                                                                                                                                                             |
| Of Amount              |                                                                                                                                                                                                                                                                             |
| Score                  | Enter a numerical score value to update when collected.                                                                                                                                                                                                                     |
| IsMultiLevel           | Enabling this parameter can upgrade to a higher value on level up                                                                                                                                                                                                           |
| limit                  |                                                                                                                                                                                                                                                                             |
| Show Progress          |                                                                                                                                                                                                                                                                             |
| Is Ascending           |                                                                                                                                                                                                                                                                             |
| Broadcast              | <p>Choose to enter a broadcast that can be used as a trigger for any other behaviour.<br>The broadcast is sent when the item is collected</p>                                                                                                                               |
| Broadcast stack empty  |                                                                                                                                                                                                                                                                             |

### Accessing the Deposit Template using T\#

Currently, there's no T# Wrapper available to customize this logic template beyond the scene editor's capabilities. However, you can write your own code in T# to implement this logic from scratch.


# Carryable

A carriable is a logic template that, when attached to a game asset, enables the player to carry it.&#x20;

To add the Carryable logic template, follow these steps:

1. Go to the Logic Tab.
2. Select Carryable under the header "Mechanics".
3. Drag and drop it onto the desired asset.

To add the Carryable behavior to an asset, follow these steps:

{% embed url="https://www.loom.com/share/f67cf9873a584bebae54cf5c94e1ffda?sid=f7158aca-4596-4c1d-b54d-f1bd5877fddb" %}
Carriable and deposit
{% endembed %}

1. Select the asset you wish to apply the Carriable behavior to.
2. In the Inspector panel, click on **Add Behavior**.
3. From the list of behaviors, choose Carriable.

You can customize the below-mentioned parameters according to your requirements:

| Parameter          | Description                                                                                                                                                                                                                             |
| ------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Group              | You can group the carryables in different categories using this dropdown.                                                                                                                                                               |
| Carry on           | <p></p><p>Choose when the item is carried, using the dropdown:</p><ul><li>when player touches</li><li>when clicked on screen</li><li>when in a magnet range</li><li>When the player has to stay near it for a specific time</li></ul> |
| Play SFX           | Choose a short chime to play when item is collected                                                                                                                                                                                     |
| Play VFX           | Choose a small visual effect to play when item is collected                                                                                                                                                                             |
| Size of carriable  |                                                                                                                                                                                                                                         |
| Score Group        | The point of the Collectable will be contributed to the score group. You can either add it to Main Score group or make your own custom group                                                                                            |
| Lerp               |                                                                                                                                                                                                                                         |
| Lerp Time          |                                                                                                                                                                                                                                         |
| Score              | Enter a numerical score value to update when collected.                                                                                                                                                                                 |
| IsMultiLevel       | Enabling this parameter can upgrade to a higher value on level up                                                                                                                                                                       |
| Broadcast          | <p>Choose to enter a broadcast that can be used as a trigger for any other behaviour.<br>The broadcast is sent when the item is collected</p>                                                                                           |

Configure the player setting for the carryable behaviour:

1. Navigate to the essentials tab from the builder menu.
2. Select the PlayerControllerDrawer from the builder panel. this would open the inspector panel
3. Navigate to carryable properties section in the inspector pannel.

| Parameter             | Description                                                                  |
| --------------------- | ---------------------------------------------------------------------------- |
| Locator for cariable  | set the position of the carryable on the player using the record button      |
| Limit                 | the number of carryables can be limited using this field                     |
| Stack offset          | Using this option you can set the position of the carrible around the player |

### Accessing the Carryable Template using T\#

Currently, there's no T# Wrapper available to customize this logic template beyond the scene editor's capabilities. However, you can write your own code in T# to implement this logic from scratch.

# Modify Carryable

The Modify Carryable Logic Template allows you to modify the number of carryables carried. &#x20;

To add the Modify Carryable logic template, follow these steps:

1. Go to the Logic Tab.
2. Select Modify Carryable under the header "Mechanics".
3. Drag and drop it onto the desired asset.

You can customize the below-mentioned parameters according to your requirements:

| Parameter                                         | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| ------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| <mark style="color:blue;">`Modify When`</mark>    | <p>This is a dropdown from where you need select any one of the following Start Events for the template<br> <br><br>1. When any other Asset touches the currently selected Asset: Select "Other Object Touch"<br>2. When a particular broadcast is generated in the game: Select "Broadcast Listened" and specify the name of the signal to listen to<br>3. When the player touches the currently selected Asset: Select "Player Touchers"<br>4. When the Asset is clicked: Select "On Click" </p> |
| <mark style="color:blue;">`Play VFX`</mark>       | Choose a small visual effect to play on the execution                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| <mark style="color:blue;">`Play SFX`</mark>       | Choose a sound effect to play on the execution                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| <mark style="color:blue;">`Haptics`</mark>        | Select Haptics from a dropdown                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| <mark style="color:blue;">`Modifier Group`</mark> | Select a which carryable needs to be modified                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| <mark style="color:blue;">`Execute Always`</mark> | Toggle to Specify if this always needs to be executed                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| <mark style="color:blue;">`Modifier`</mark>       | Select a modifier to the carriable - Add, Subtract, Multiply                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| <mark style="color:blue;">`Modify By`</mark>      | Amount / Value to be modified by                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |

### Accessing the Modify Carryable Template using T\#

Currently, there's no T# Wrapper available to customize this logic template beyond the scene editor's capabilities. However, you can write your own code in T# to implement this logic from scratch.


# Treadmill

The Treadmill Logic Template simulates treadmill movement for objects or the Player upon touch.

To add the Treadmill logic template, follow these steps:

1. Go to the Logic Tab.
2. Select Treadmill under the header "Mechanics".
3. Drag and drop it onto the desired asset.

You can edit the following parameters of this template directly through the scene editor interface:

| Parameter                                             | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| ----------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| <mark style="color:blue;">`Treadmill When`</mark>     | <p>This is a dropdown from where you need select any one of the following Start Events for the template<br> <br>1. When the behavior  when the game starts: Select "Game Start"<br>2. When any other Asset touches the currently selected Asset: Select "Other Object Touch"<br>3. When a particular broadcast is generated in the game: Select "Broadcast Listened" and specify the name of the signal to listen to<br>4. When the player touches the currently selected Asset: Select "Player Touchers"<br>5. When the Asset is clicked: Select "On Click" </p> |
| <mark style="color:blue;">`Play SFX`</mark>           | Choose a short chime to play when the player starts the treadmill                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| <mark style="color:blue;">`Play VFX`</mark>           | Choose a small visual effect to play on the object when the player starts the treadmill                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| <mark style="color:blue;">`Treading Speed`</mark>     | Specify the speed of the treadmill                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| <mark style="color:blue;">`Treading Direction`</mark> | Specify the direction of movement of the treadmill                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| <mark style="color:blue;">`broadcastData`</mark>      | Specify a broadcast signal to be generated after execution                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |

### Accessing the Treadmill Template using T\#

Currently, there's no T# Wrapper available to customize this logic template beyond the scene editor's capabilities. However, you can write your own code in T# to implement this logic from scratch.


# Attach Object

The Attach Object Logic Template allows you to attach one object to another, making the new object a child of the original object.

To add the Attach Object logic template, follow these steps:

1. Go to the Logic Tab.
2. Select Attach Object under the header "Mechanics".
3. Drag and drop it onto the desired asset.

You can edit the following parameters of this template directly through the scene editor interface:

| Parameter                                       | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| ----------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| <mark style="color:blue;">`AttachOn`</mark>     | <p>This is a dropdown from where you need select any one of the following Start Events for the template<br> <br>1. When the behavior  when the game starts: Select "Game Start"<br>2. When any other Asset touches the currently selected Asset: Select "Other Object Touch"<br>3. When a particular broadcast is generated in the game: Select "Broadcast Listened" and specify the name of the signal to listen to<br>4. When the player touches the currently selected Asset: Select "Player Touchers"<br>5. When the Asset is clicked: Select "On Click" </p> |
| <mark style="color:blue;">`Attach_To`</mark>    | Select from the dropdown whether you want to attach the object to the Player or A Game Object.                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| <mark style="color:blue;">`Attach To`</mark>    | <p>If you chose GameObject, drag and drop the game object references from the layers here.<br><br>This will be set to None if you selected Player on Attach_To</p>                                                                                                                                                                                                                                                                                                                                                                                                |
| <mark style="color:blue;">`KeepWorldPos`</mark> | Toggle to indicate if you want to keep the world position of the object                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| <mark style="color:blue;">`Offset`</mark>       | Indicate the offset between the parent and the child                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |

### Accessing Attach Object using T\#

Currently, there's no T# Wrapper available to customize this logic template beyond the scene editor's capabilities. However, you can write your own code in T# to implement this logic from scratch.


# Hinge Joint

The Hinge Joint Logic Template allows you to make an asset rotate around a hinge joint to mimic the movement of a door.  &#x20;

To add the Hinge Joint logic template, follow these steps:

1. Go to the Logic Tab.
2. Select Hinge Joint under the header "Mechanics".
3. Drag and drop it onto the desired asset.

You can edit the following parameters of this template directly through the scene editor interface:

| Parameter                                        | Description                                                                            |
| ------------------------------------------------ | -------------------------------------------------------------------------------------- |
| <mark style="color:blue;">`Axis`</mark>          | Helps specify the axis of rotation                                                     |
| <mark style="color:blue;">`Anchor`</mark>        | Specify the anchor point around which hinge movement must happen                       |
| <mark style="color:blue;">`Can Spin Back`</mark> | Toggle to specify if the object can spin back to original position after the rotation. |

### Accessing the Hinge JointTemplate using T\#

Currently, there's no T# Wrapper available to customize this logic template beyond the scene editor's capabilities. However, you can write your own code in T# to implement this logic from scratch.



# Simulator Templates


# Helper

Helpers are a unique type of behavior commonly utilized in Tycoon Games. They provide creators with the capability to assign behaviors to NPC assets, enabling them to execute a predefined set of actions. For example, by applying the Helper behavior to a "bunny" and specifying actions such as gathering fruits from trees (generated by generators) and organizing them on store shelves (Storage deposit).

To add the Helper behavior to an asset, follow these steps:

1. Select the asset you wish to apply the Helper behavior to.
2. In the Inspector panel, click on **Add Behavior**.
3. From the list of behaviors, choose **Helper.**

You can customize the below-mentioned parameters according to your requirements:

| Parameter               | Description                                                                                                                                                                                                           |
| ----------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Collect When            | <p></p><p>Choose when the item is collected:</p><ul><li>when player touches</li><li>when clicked on screen</li><li>when in a magnet range</li><li>When the player has to stay near it for a specific time</li></ul> |
| Sound Effect on Start   | Choose a short chime to play when item is collected                                                                                                                                                                   |
| Visual Effect on Start  | Choose a small visual effect to play when item is collected                                                                                                                                                           |
| Score Group             | The point of the Collectable will be contributed to the score group. You can either add it to Main Score group or make your own custom group                                                                          |
| Update Score By         | <p>Enter a numerical score value to update when collected.<br> Note: to reduce a score when collected, enter a negative value!</p>                                                                                   |
| IsMultiLevel            | Enabling this parameter can upgrade to a higher value on level up                                                                                                                                                     |
| Broadcast On Collection | <p>Choose to enter a broadcast that can be used as a trigger for any other behaviour.<br>The broadcast is sent when the item is collected</p>                                                                         |

# Cash Counter

Cash Counters are a unique behavior often found in Tycoon Games. They enable creators to assign behaviors to assets, facilitating financial transactions within the game by invoicing customers according to their orders. For example, in a self-service store scenario, when a customer brings their desired items to the cash counter, it generates a bill based on their order and proceeds to collect payment from the customer.

| Parameters  | Type                                                                               |
| ----------- | ---------------------------------------------------------------------------------- |
| Start Event |                                                                                    |
| Effects     | Creates Game Scene Objects, Generate a Broadcast Signal, Enable an SFX or Particle |
| Type        | Independent                                                                        |

To add the Cash Counters behavior to an asset, follow these steps:

1. Select the asset you wish to apply the Cash Counters behavior to.
2. In the Inspector panel, click on **Add Behavior**.
3. From the list of behaviors, choose **Cash Counters.**

You can customize the below-mentioned parameters according to your requirements:

| Parameter               | Description                                                                                                                                                                                                           |
| ----------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Collect When            | <p></p><p>Choose when the item is collected:</p><ul><li>when player touches</li><li>when clicked on screen</li><li>when in a magnet range</li><li>When the player has to stay near it for a specific time</li></ul> |
| Sound Effect on Start   | Choose a short chime to play when item is collected                                                                                                                                                                   |
| Visual Effect on Start  | Choose a small visual effect to play when item is collected                                                                                                                                                           |
| Score Group             | The point of the Collectable will be contributed to the score group. You can either add it to Main Score group or make your own custom group                                                                          |
| Update Score By         | <p>Enter a numerical score value to update when collected.<br> Note: to reduce a score when collected, enter a negative value!</p>                                                                                   |
| IsMultiLevel            | Enabling this parameter can upgrade to a higher value on level up                                                                                                                                                     |
| Broadcast On Collection | <p>Choose to enter a broadcast that can be used as a trigger for any other behaviour.<br>The broadcast is sent when the item is collected</p>                                                                         |

# Convertible

Convertible are a distinct type of behavior frequently employed in Tycoon Games. They grant creators the ability to assign behaviors to assets, allowing them to transform one type of asset into another. For instance, by applying the Convertible behavior to a "coffee grinding machine," it gains the capability to produce ground coffee and package it into bags at a set rate.

To add the Converter behavior to an asset, follow these steps:

1. Select the asset you wish to apply the Converter behavior to.
2. In the Inspector panel, click on **Add Behavior**.
3. From the list of behaviors, choose **Converter.**

You can customize the below-mentioned parameters according to your requirements:

<table><thead><tr><th width="384">Parameter</th><th>Description</th></tr></thead><tbody><tr><td>Input Type</td><td>This is the option where you can select the type of Input:<br>1. Storage<br>2.Carriable </td></tr><tr><td>Input/s</td><td>storage name of the input need to be added here</td></tr><tr><td>#each input for 1 output</td><td>Here you can set the number of units of input that will be need for 1 unit of output</td></tr><tr><td>Conversion time</td><td>You can define the time that will be taken for the inversion of each unit of input to output</td></tr><tr><td>Delay between conversion</td><td>You can set the delay between the conversion of one unity of input to output</td></tr><tr><td>Pause on</td><td>You can use this option to specify when the conversion  process will be paused.<br>1. Player stay - if the player waits around the storage deposit <br>2. clicked- if the player clicks on the storage deposit<br>3. Broadcast listen- When a particular broadcast is generated in the game</td></tr><tr><td>Restart on</td><td>You can use this option to specify when the conversion  process will be Restarted.<br>1. Player stay - if the player waits around the storage deposit <br>2. clicked- if the player clicks on the storage deposit<br>3. Broadcast listen- When a particular broadcast is generated in the game</td></tr><tr><td>Output type</td><td>This is the option where you can select the type of output:<br>1. Storage<br>2.Carriable </td></tr><tr><td>Storage Tag</td><td>For storage type output, you are use this option to select the respective output storage</td></tr><tr><td>Special broadcast</td><td>Choose to enter a broadcast that can be used as a trigger for any other behavior. </td></tr></tbody></table>

# Output/Generator

Output/Generators are a specific type of behaviour commonly utilized in Tycoon Games. T_hey empower creators to assign behaviors to assets, enabling them to produce specific types of assets._ For example, the Generator behavior can be applied to a "coconut tree," granting it the capability to produce coconuts at a predetermined rate.

To create a Generator, follow these steps:

1. Create an empty object.
2. Add the asset that will act as a generator as a child to this empty object.
3. Add the generator behavior to the asset.
4. Add the asset that you want the generator to generate as the child of the generator asset.
5. Add the expected behaviour of the generated asset. (carriable)

You can customize the below-mentioned parameters of generator behaviour according to your requirements:

<table><thead><tr><th width="384">Parameter</th><th>Description</th></tr></thead><tbody><tr><td>Type</td><td>This is the option where you can select the type of Output/generator:<br>1. Self - It generates the output itself <br>2. Converter - It collects the output from the converter.</td></tr><tr><td>Activate On</td><td>This is a dropdown from where you need select any one of the following Start Events for Generator to begin executing: <br> <br>1. When the game starts: Select "Game Start"<br>2. When any other Asset touches the currently selected Asset: Select "Other Object Touch"<br>3. When a particular broadcast is generated in the game: Select "Broadcast Listened" and specify the name of the signal to listen to<br>4. When the player touches the currently selected Asset: Select "Player Touchers"<br>5. When the Asset is clicked: Select "On Click"</td></tr><tr><td>Carriable Output </td><td><p>This field is used to define the asset that would get generated using this behaviour. <br>There are three option available:<br>1. None<br>2. Custom </p><p>3. Select the carriable group</p></td></tr><tr><td>Storage limit</td><td>You can use this field to set the limit of the assets that will get generated </td></tr><tr><td>Generate Time</td><td>You can use this field to specify the time it will take to generate an asset (in seconds)</td></tr><tr><td>No Limit</td><td>checking this checkbox would remove any limit on the number of assets generated</td></tr><tr><td>Carriable position</td><td>Using this record option, you can specify the location of each carriable. Just drag and drop the ghost of the carriable to the desired location. Click on the "Add Point" option to fix the location.</td></tr><tr><td>Stack offset</td><td>This option can be used to adjust the position of each carriable with respect to one another.</td></tr><tr><td>Storage Name</td><td>You can specify the storage name where you want the generated assets to be stored </td></tr><tr><td>Show UI</td><td>Selecting this checkbox will cause a UI element to appear above the generator, displaying the number of generated assets.</td></tr><tr><td>Progress UI</td><td>This drop down provides the option how you like the generation progress to be reflected. There are 3 available option:<br>1. Absolute <br>2. Percentage <br>3. X/Y</td></tr><tr><td>Local position</td><td>offset of the Ui</td></tr><tr><td>Play SFX</td><td>Choose a short chime to play when item is collected</td></tr><tr><td>Play VFX</td><td>Choose a small visual effect to play when item is collected</td></tr><tr><td>Collect on</td><td><p>This is a dropdown from where you need select the trigger that will start the collection process:<br>1. On touching the asset : Select "Touched Me"<br>2. On clicking a paticular carriable: Select "Clicked carriable".</p><p>3.On clicking the asset : Select "Touched Me"<br>3. When a particular broadcast is generated in the game: Select "Broadcast Listened" and specify the name of the signal to listen to<br>4. When the player touches the currently selected Asset: Select "Player Touchers"<br>5. When the Asset is clicked: Select "On Click"</p></td></tr><tr><td>Delay</td><td>You can specify the delay after which the carriable will start being collected.</td></tr><tr><td>Collect Rate </td><td>You can specify the speed at which the carriable will be collected.</td></tr><tr><td>Special broadcast</td><td>Choose to enter a broadcast that can be used as a trigger for any other behavior. <br>The broadcast is sent when you click on the asset.</td></tr></tbody></table>

# Self-service customer

Self-service customers are a distinctive behavior type frequently employed in Tycoon Games. They allow creators to simulate customer actions using NPC assets, particularly in self-service stores. For instance, applying the Self-service customer behavior to a "bunny" visiting a store to purchase 5 apples, 6 eggs, and 2 bananas would prompt the NPC to enter the store, locate the respective shelves, collect the desired items, proceed to the checkout counter for billing, and finally, complete the transaction to obtain the items.

To add the Self-service customers behavior to an asset, follow these steps:

1. Select the asset you wish to apply the Self-service customers behavior to.
2. In the Inspector panel, click on **Add Behavior**.
3. From the list of behaviors, choose **Self-service customers.**

You can customize the below-mentioned parameters according to your requirements:

| Parameter                  | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| -------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| Self service customer when | <p></p><p>This is a dropdown from where you need select any one of the following Start Events for this behaviour initiate: <br> <br>1.. When any other Asset touches the currently selected Asset: Select "Other Object Touch"<br>2. When a particular broadcast is generated in the game: Select "Broadcast Listened" and specify the name of the signal to listen to<br>3. When the player touches the currently selected Asset: Select "Player Touchers"<br>4. When the Asset is clicked: Select "On Click"</p> |
| Sound Effect on Start      | Choose a short chime to play on behaviour execution                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Visual Effect on Start     | Choose a small visual effect to play n behaviour execution                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| Broadcast On Collection    | <p>Choose to enter a broadcast that can be used as a trigger for any other behaviour.<br>The broadcast is sent when the item is collected</p>                                                                                                                                                                                                                                                                                                                                                                      |

# Storage/input

Storage deposit are a distinct type of behavior frequently employed in Tycoon Games. They grant creators the ability to assign behaviors to assets, allowing act as a storage units or selves of a paticalar kind of asset. For instance, by applying the Storage deposit behavior to a "store selves of a grocery store," it gains the capability to store a paticular kind of grocery item.

To add the Storage deposit behavior to an asset, follow these steps:

1. Select the asset you wish to apply the Converter behavior to.
2. In the Inspector panel, click on **Add Behavior**.
3. From the list of behaviors, choose **Storage deposit.**

You can customize the below-mentioned parameters according to your requirements:

<table><thead><tr><th width="384">Parameter</th><th>Description</th></tr></thead><tbody><tr><td>Storage Name</td><td>You can add custom storage name here.</td></tr><tr><td>Store When</td><td>This is a dropdown from where you need select any one of the following Start Events for collection to begin executing: <br> <br>1.. When any other Asset touches the currently selected Asset: Select "Other Object Touch"<br>2. When a particular broadcast is generated in the game: Select "Broadcast Listened" and specify the name of the signal to listen to<br>3. When the player touches the currently selected Asset: Select "Player Touchers"<br>4. When the Asset is clicked: Select "On Click"<br>5. Trigger</td></tr><tr><td>Delay</td><td>pause before the carriable gets deposited</td></tr><tr><td>Carriable Input</td><td>This field is used to define the carriable that would get collected using this behaviour. <br>There are two option available:<br>1. None<br>2. Custom <br>3. Select the carriable group</td></tr><tr><td>No Limit</td><td>checking this checkbox would remove any limit on the number of carriable stored</td></tr><tr><td>Storage limit</td><td>You can use this field to set the limit of the assets that will get stored. </td></tr><tr><td>Stack offset</td><td>This option can be used to adjust the position of the carriable in the storage</td></tr><tr><td>Deposit Rate</td><td>You can use this field to specify the rate at which asset will get depositted.</td></tr><tr><td>Customer position</td><td>Position where the customer will stand in queue to collect the particular carriable.</td></tr><tr><td>Carriable position </td><td>position where the carriable to get collected can be specified using this option</td></tr><tr><td>Show UI</td><td>Selecting this checkbox will cause a UI element to appear above the storage deposit, displaying the number of collected assets.</td></tr><tr><td>Progress UI</td><td>This drop down provides the option how you like the collection progress to be reflected. There are 3 available option:<br>1. Absolute <br>2. Percentage <br>3. X/Y</td></tr><tr><td>Local position</td><td>offset of the UI</td></tr><tr><td>Play SFX</td><td>Choose a short chime to play when item is collected</td></tr><tr><td>Play VFX</td><td>Choose a small visual effect to play when item is collected</td></tr><tr><td>BroadcastData</td><td>Choose to enter a broadcast that can be used as a trigger for any other behavior. <br></td></tr><tr><td>Customer</td><td>the item that customer needs to collect will be reflected as an icon above the customer </td></tr><tr><td>Show separate </td><td></td></tr></tbody></table>



# Actions

<table><thead><tr><th width="260">Logic Template</th><th>Description</th></tr></thead><tbody><tr><td><a href="destroy.md">Destroy</a></td><td>Destroys the Asset from the scene</td></tr><tr><td><a href="set-position.md">Set Position</a></td><td>Changes the Asset's position</td></tr><tr><td><a href="advance-instantiate.md">Advance Instantiate</a></td><td></td></tr><tr><td><a href="grow-shrink.md">Grow / Shrink</a></td><td>Increases or decreases the size of the Asset</td></tr><tr><td><a href="move.md">Move</a></td><td>Moves the Asset in a straight line path to a specified new position from its starting point.</td></tr><tr><td><a href="rotate.md">Rotate</a></td><td>Rotates the Asset about a chosen axis</td></tr><tr><td><a href="move-to-player.md">Move To Player</a></td><td>Moves the Asset to the Player</td></tr><tr><td><a href="rotate-oscillate.md">Rotate Oscillate </a></td><td>Oscilates the Asset about a specified axis within a specified rotation about the initial position</td></tr><tr><td><a href="basic-instantiate.md">Basic Instantiate</a></td><td></td></tr><tr><td><a href="bump.md">Bump</a></td><td>Bounce back when you run into it</td></tr><tr><td><a href="broken-reference">Destroy Persistently</a></td><td>Destroys objects </td></tr></tbody></table>

# Bump

The Bump logic template 'bumps' and pushes any asset that contacts the asset it is applied to.

To add the Bump logic template to an asset, follow these steps:

1. Go to the Logic Tab.
2. Select Bump under the header "Action".
3. Drag and drop it onto the desired asset.

You can edit the following parameters of this template directly through the scene editor interface:

<table><thead><tr><th width="452">Parameters</th><th>Description</th></tr></thead><tbody><tr><td>Force</td><td>Enter the force to be applied</td></tr><tr><td>Play SFX</td><td>Choose a sound effect to play when the asset is destroyed.</td></tr><tr><td>Play VFX</td><td>Choose a visual effect to play when the asset is destroyed.</td></tr><tr><td>Broadcast Data</td><td>Choose to enter a broadcast that can be used as a trigger for any other behavior. <br>The broadcast is sent when the asset is destroyed.</td></tr><tr><td>Type</td><td>Choose from a dropdown whether the bump needs to be a Reflect or a Deflect</td></tr></tbody></table>

### Accessing the Bump Logic Template using T\#

There are currently no available T# Wrappers for this template.

# Move

The Move behaviour can be attached to objects to give them mobility. Objects can move along all three axes, oscillate between two points, and send broadcasts to trigger additional behaviour.

To add the Move logic template to an asset, follow these steps:

1. Go to the Logic Tab.
2. Select Move under the header "Action".
3. Drag and drop it onto the desired asset.

You can edit the following parameters of this template directly through the scene editor interface:

<table><thead><tr><th width="239">Parameter</th><th>Description</th></tr></thead><tbody><tr><td>Move When</td><td><p>You can choose the trigger to activate the behaviour </p><p>- When the game starts<br>- After a broadcast message has been received by the object<br>- When the player touches the object<br>- When a different object touches the object<br>- When you click on the object</p></td></tr><tr><td>Speed</td><td>You can define the speed of the object</td></tr><tr><td>Loop-able</td><td>This allows you to loop the movement of the object. It appears as if it is oscillating between 2 different points.</td></tr><tr><td>Interval</td><td>Intervals add a delay between the back-and-forth movement of the object during the loop.</td></tr><tr><td>Move By</td><td>You can define how many units and in what axis the object will move</td></tr><tr><td>Sound Effect on Start</td><td>Choose a sound effect to play when the object starts to move</td></tr><tr><td>Visual Effect on Start</td><td>Choose a visual effect to play when the object starts to move</td></tr><tr><td>Broadcast on End</td><td>Choose to enter a broadcast that can be used as a trigger for any other behavior. <br>The broadcast is sent when the object stops moving.</td></tr><tr><td>Stop When</td><td>You can choose the trigger to stop the movement<br>- After a broadcast message has been received by the object<br>- When the player touches the object<br>- When a different object touches the object<br>- When you click on the object</td></tr><tr><td>Resume When</td><td>You can choose the trigger to resume the movement<br>- After a broadcast message has been received by the object<br>- When the player touches the object<br>- When a different object touches the object<br>- When you click on the object.</td></tr></tbody></table>

### Accessing the Move Logic Template using T\#

If you want to further customize this logic template, you can do so by accessing its T# Wrapper - [MoveTemplate](../../coding-using-t/t-logic-template-wrappers.md#movetemplate)

# Basic Instantiate

The Basic Instantiate behavior facilitates the dynamic spawning of identical objects in various locations during gameplay. It allows for controlled timing and quantity of object spawns.

You can determine where objects appear in the game scene by specifying a range of X, Y, and Z coordinates or by randomizing their location within a designated area. With the first method, you have precise control over the specific combinations of coordinates where objects will spawn. Alternatively, using the random allocation option, you can define an area using the record feature, allowing objects to appear randomly within that area during gameplay.

To add the Basic Instantiate logic template to an asset, follow these steps:

1. Go to the Logic Tab.
2. Select Basic Instantiate under the header "Action".
3. Drag and drop it onto the desired asset.&#x20;

{% embed url="https://www.loom.com/share/151848e0501949b2b72dd42969d93343?sid=9ae333cc-1a8d-4ac6-b363-b5c8d1a4fe29" %}

You can edit the following parameters of this template directly through the scene editor interface:

| Parameters      | Description                                                                                                                                                                                                                                                                                                                                                   |
| --------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Instantiate On  | <p>You can choose the start event from the dropdown to activate the behaviour<br>- After a broadcast message has been received by the asset<br>- When the game starts</p>                                                                                                                                                                                     |
| Repeat On Event | If you check this box, the asset will appear only once in the scene                                                                                                                                                                                                                                                                                           |
| No of instance  | You can set how many assets will respawn at a time                                                                                                                                                                                                                                                                                                            |
| Position        | <p>You can choose where you want the assets to respawn using the dropdown. You can choose from:<br>- Locator: Objects will spawn at specific coordinates. You can set the coordinates by clicking the "+" sign below the location positions.<br>- Random in area: Objects will spawn at random coordinates. You can define the area using record feature.</p> |
| Randomise       | This parameter is specifically for locators. It causes objects to spawn at the specified coordinates, but the order of the coordinates will be randomized, disregarding the order in which they were defined.                                                                                                                                                 |
| Play SFX        | Choose a sound effect to play every time the asset spawns                                                                                                                                                                                                                                                                                                     |
| Play VFX        | Choose a visual effect to play every time the asset spawns                                                                                                                                                                                                                                                                                                    |
| Broadcast       | <p>Choose to enter a broadcast that can be used as a trigger for any other behavior. <br>The broadcast is sent when the assets spawn.</p>                                                                                                                                                                                                                     |

### Accessing the Basic Instantiate Logic Template using T\#

There are currently no available T# wrappers to access this template.&#x20;

# Grow / Shrink

The Grow or Shrink behavior can be used to change the size of an object. Various types of triggers can be used to grow or shrink the object.

To add the Grow/Shrink logic template to an asset, follow these steps:

1. Go to the Logic Tab.
2. Select Grow/Shrink under the header "Action".
3. Drag and drop it onto the desired asset.

You can edit the following parameters of this template directly through the scene editor interface:

<table><thead><tr><th width="216">Parameters</th><th>Description</th></tr></thead><tbody><tr><td>Grow When</td><td>You can choose the trigger on which the object will start growing.<br>- It can be at the start of the game<br>- After a broadcast message has been received by the object.<br>- When the player touches the object.<br>- When a different object touches the object.<br>- When you click on the object.<br></td></tr><tr><td>Scale by</td><td>You can specify the scale by which an object's size will grow or shrink</td></tr><tr><td>Speed</td><td>You can define the speed by which object will grow or shrink</td></tr><tr><td>Repeat </td><td>You can define the number of time you want the behaviour to be executed </td></tr><tr><td>Repeat forever </td><td>You can set the change in size behaviour to forever by checking this checkbox.</td></tr><tr><td>Pause for</td><td>The duration of the pause between each cycle of behaviour execution can be adjusted here</td></tr><tr><td>Repeat type </td><td>You can use this option to select the type of motion while change<br>There are two types motion the behaviour supports at the moment <br>1. Ping Pong<br>2. Same Direction </td></tr><tr><td>Broadcast </td><td>Choose to enter a broadcast that can be used as a trigger for any other behavior. <br>The broadcast is sent when the object stops moving.</td></tr><tr><td>Sound Effect on Start</td><td>Choose a sound effect to play when object starts moving</td></tr><tr><td>Visual Effect on Start</td><td>Choose a visual effect to play when object starts moving</td></tr></tbody></table>

### Accessing the Grow/Shrink Logic Template using T\#

If you want to further customize this logic template, you can do so by accessing its T# Wrapper - [GrowTemplate](../../coding-using-t/t-logic-template-wrappers.md#growtemplate)


# Rotate

When the Rotate logic template is applied to objects, they begin to rotate about their axis upon a specific trigger.

To add the Rotate logic template to an asset, follow these steps:

1. Go to the Logic Tab.
2. Select Rotate under the header "Action".
3. Drag and drop it onto the desired asset.

You can edit the following parameters of this template directly through the scene editor interface:

<table><thead><tr><th width="216">Parameters</th><th>Description</th></tr></thead><tbody><tr><td>Rotate When</td><td>You can choose the trigger on which the object will start rotating.<br>- It can be at the start of the game<br>- After a broadcast message has been received by the object.<br>- When the player touches the object.<br>- When a different object touches the object.<br>- When you click on the object.<br></td></tr><tr><td>Rotation Axis</td><td>You can choose the axis in which the object will rotate (X,Y,Z axis)</td></tr><tr><td>Speed</td><td>You can define the rotation speed of the object</td></tr><tr><td>Direction</td><td>You can define the direction of motion either clockwise or anticlockwise</td></tr><tr><td>Sound Effect on Start</td><td>Choose a sound effect to play when object starts moving</td></tr><tr><td>Visual Effect on Start</td><td>Choose a visual effect to play when object starts moving</td></tr><tr><td>Stop When</td><td>You can choose which trigger will stop the movement. Those can be:<br>- After a broadcast message has been received by the object.<br>- When the player touches the object.<br>- When a different object touches the object.<br>- When you click on the object.</td></tr><tr><td>Restart When</td><td>You can choose which trigger will restart the movement. Those can be:<br>- After a broadcast message has been received by the object.<br>- When the player touches the object.<br>- When a different object touches the object.<br>- When you click on the object.</td></tr></tbody></table>

### Accessing the Rotate Logic Template using T\#

If you want to further customize this logic template, you can do so by accessing its T# Wrapper - [RotateTemplate](../../coding-using-t/t-logic-template-wrappers.md#rotatetemplate)


# Rotate Oscillate

When the Rotate Oscillate logic template is applied to objects, they begin to oscillate around their axis at a defined angle and speed upon a specific trigger.

To add the Rotate Oscillate logic template to an asset, follow these steps:

1. Go to the Logic Tab.
2. Select Rotate Oscillate under the header "Action".
3. Drag and drop it onto the desired asset.

You can edit the following parameters of this template directly through the scene editor interface:

<table><thead><tr><th width="216">Parameters</th><th>Description</th></tr></thead><tbody><tr><td>Rotate On</td><td>You can choose the trigger on which the object will start rotating.<br>- It can be at the start of the game<br>- After a broadcast message has been received by the object.<br>- When the player touches the object.<br>- When a different object touches the object.<br>- When you click on the object.<br></td></tr><tr><td>Axis</td><td>You can choose the axis about which the object will oscillate (X,Y,Z axis)</td></tr><tr><td>Speed</td><td>You can define the rotation speed of the object</td></tr><tr><td>Degrees</td><td>define the angle at which the object would oscillate </td></tr><tr><td>Direction</td><td>You can define the direction of motion either clockwise or anticlockwise</td></tr><tr><td>Repeat</td><td>You can define the number of time you want the oscillation to occur</td></tr><tr><td>Repeat Forever </td><td>You can set the oscillation to forever by checking this checkbox.</td></tr><tr><td>Sound Effect on Start</td><td>Choose a sound effect to play when object starts moving</td></tr><tr><td>Visual Effect on Start</td><td>Choose a visual effect to play when object starts moving</td></tr><tr><td>Broadcast </td><td>Choose to enter a broadcast that can be used as a trigger for any other behavior. <br>The broadcast is sent when the object stops moving.</td></tr><tr><td>Stop On</td><td>You can choose which trigger will stop the movement. Those can be:<br>- After a broadcast message has been received by the object.<br>- When the player touches the object.<br>- When a different object touches the object.<br>- When you click on the object.</td></tr><tr><td>Restart On</td><td>You can choose which trigger will restart the movement. Those can be:<br>- After a broadcast message has been received by the object.<br>- When the player touches the object.<br>- When a different object touches the object.<br>- When you click on the object.</td></tr></tbody></table>

### Accessing the Rotate Oscillate Logic Template using T\#

If you want to further customize this logic template, you can do so by accessing its T# Wrapper - [RotateOscillateTemplate](../../coding-using-t/t-logic-template-wrappers.md#rotateoscillatetemplate)

# Set Position

The Set Position logic template enables you to specify the position of an asset.

To add the Set Position logic template to an asset, follow these steps:

1. Go to the Logic Tab.
2. Select Set Position under the header "Action".
3. Drag and drop it onto the desired asset.

You can edit the following parameters of this template directly through the scene editor interface:

<table><thead><tr><th width="452">Parameters</th><th>Description</th></tr></thead><tbody><tr><td>Set Position on</td><td><p>- When the game starts</p><p>- When a different asset touches the asset having the behaviour<br>- After a broadcast message has been received by the asset. <br>- When the player touches the asset.<br>- When the object is clicked.</p></td></tr><tr><td>Target</td><td>Specify the target destination position either by recording or entering the target coordinates in the fields X, Y and Z.</td></tr><tr><td>Play SFX</td><td>Choose a sound effect to play on execution</td></tr><tr><td>Play VFX</td><td>Choose a visual effect to play on execution</td></tr><tr><td>Broadcast Data</td><td>Choose to enter a broadcast that can be used as a trigger for any other behavior. <br>The broadcast is sent when the asset is destroyed.</td></tr></tbody></table>

### Accessing the Set Position Logic Template using T\#

If you want to further customize this logic template, you can do so by accessing its T# Wrapper - [SetPositionTemplate](../../coding-using-t/t-logic-template-wrappers.md#setpositiontemplate)

# Move To Player

Objects with the MoveToPlayer behavior will leave their designated location and move towards the player. They track the player's movement and follow in the same direction. Multiple triggers can activate this behavior as needed.

To add the Move To Player logic template to an asset, follow these steps:

1. Go to the Logic Tab.
2. Select Move To Player under the header "Action".
3. Drag and drop it onto the desired asset.

You can edit the following parameters of this template directly through the scene editor interface:

<table><thead><tr><th width="306">Parameter</th><th>Description</th></tr></thead><tbody><tr><td>MoveToPlayerWhen</td><td>You can choose the trigger to activate the behaviour<br>- After a broadcast message has been received by the object<br>- When the player touches the object<br>- When a different object touches the object<br>- When you click on the object</td></tr><tr><td>MoveSpeed</td><td>You can fix the speed for object movement</td></tr><tr><td>Offset</td><td>Specifying offset value ensures that the object will move a specific number of units in the given axis. It won't follow you but will relocate to a different location on triggering.</td></tr><tr><td>Play SFX</td><td>Choose a sound effect to play when you collide with the object.</td></tr><tr><td>Play VFX</td><td>Choose a sound effect to play when you collide with the object.</td></tr><tr><td>Cancel On</td><td>You can choose when to stop the movement of the object.<br>- After a broadcast message has been received by the object.<br>- When the player touches the object.<br>- When a different object touches the object.</td></tr><tr><td>Cancel Type</td><td>You can choose what happens to the object once it stops moving. <br>- It can relocate back to its original position.<br>- It can stop at the current position.</td></tr><tr><td>Broadcast</td><td>Choose to enter a broadcast that can be used as a trigger for any other behavior. <br>The broadcast is sent when the object comes in contact with you.</td></tr></tbody></table>

### Accessing the Move To Player Logic Template using T\#

If you want to further customize this logic template, you can do so by accessing its T# Wrapper - [MoveToPlayerTemplate](../../coding-using-t/t-logic-template-wrappers.md#movetoplayertemplate)

# Destroy

The Destroy logic template is used when you want to remove or destroy assets from the game scene on a certain trigger. The asset with this logic template are destroyed without any trace of them being there.

This logic template is very similar to the Collectable behaviour, the only difference being that the Collectable contributes to a score group and this does not. In both logic templates, the asset disappears after the trigger.

To add the Destroy logic template to an asset, follow these steps:

1. Go to the Logic Tab.
2. Select Destroy under the header "Action".
3. Drag and drop it onto the desired asset.

You can edit the following parameters of this template directly through the scene editor interface:

<table><thead><tr><th width="288">Parameters</th><th>Description</th></tr></thead><tbody><tr><td>Destroy When</td><td><p>You can choose the trigger when to destroy the asset.<br>- When the game starts</p><p>- When a different asset touches the asset having the behaviour<br>- After a broadcast message has been received by the asset. <br>- When the player touches the asset.<br>- When the object is clicked.</p></td></tr><tr><td>Play SFX</td><td>Choose a sound effect to play when the asset is destroyed.</td></tr><tr><td>Play VFX</td><td>Choose a visual effect to play when the asset is destroyed.</td></tr><tr><td>Broadcast Data</td><td>Choose to enter a broadcast that can be used as a trigger for any other behavior. <br>The broadcast is sent when the asset is destroyed.</td></tr><tr><td>Destroy After</td><td>The time in seconds after which the asset disappears from the scene.</td></tr></tbody></table>

### Accessing the Destroy Logic Template using T\#

If you want to further customize this logic template, you can do so by accessing its T# Wrapper -  [DestroyTemplate](../../coding-using-t/t-logic-template-wrappers.md#destroytemplate)

# Advance Instantiate

To add the Advance Instantiate logic template to an asset, follow these steps:

1. Go to the Logic Tab.
2. Select Advance Instantiate under the header "Action".
3. Drag and drop it onto the desired asset.

You can edit the following parameters of this template directly through the scene editor interface:

<table><thead><tr><th width="452">Parameters</th><th>Description</th></tr></thead><tbody><tr><td>Destroy When</td><td><p>You can choose the trigger when to destroy the asset.<br>- When the game starts</p><p>- When a different asset touches the asset having the behaviour<br>- After a broadcast message has been received by the asset. <br>- When the player touches the asset.<br>- When the object is clicked.</p></td></tr><tr><td>Play SFX</td><td>Choose a sound effect to play when the asset is destroyed.</td></tr><tr><td>Play VFX</td><td>Choose a visual effect to play when the asset is destroyed.</td></tr><tr><td>Broadcast Data</td><td>Choose to enter a broadcast that can be used as a trigger for any other behavior. <br>The broadcast is sent when the asset is destroyed.</td></tr><tr><td>Destroy After</td><td>The time in seconds after which the asset disappears from the scene.</td></tr></tbody></table>

### Accessing the Advance Instantiate Logic Template using T\#

There are currently no available T# Wrappers for this template.


# Effects

<table><thead><tr><th width="263">Logic Template</th><th>Description</th></tr></thead><tbody><tr><td><a href="stop-rotate.md">Stop Rotate</a></td><td>Stops Rotation </td></tr><tr><td><a href="showui/">ShowUI</a></td><td>Displays a UI on the screen</td></tr><tr><td>Stop Animation</td><td>Stops Animation </td></tr><tr><td>Play Player's Animation</td><td>Plays animation of the player</td></tr></tbody></table>

# Play Player's Animation

The Play Player's animation logic template activates a predefined player animation when the trigger condition is met.

To add the Play Player's Animation logic template to an asset, follow these steps:

1. Go to the Logic Tab.
2. Select Play Player's Animation under the header "Effects".
3. Drag and drop it onto the desired asset.

You can edit the following parameters of this template directly through the scene editor:

<table><thead><tr><th width="279">Parameters</th><th>Description</th></tr></thead><tbody><tr><td>Play On</td><td><p></p><p>Choose from the following options in the dropdown menu for when the Player animation should Start:</p><ol><li>On Game Start</li><li>On Player Touch</li><li>On Other Object Touch</li><li>On Click</li><li>On Broadcast: If selected, specify the broadcast to listen to.</li></ol></td></tr><tr><td>Broadcast</td><td>Enter a broadcast to be generated at the end of execution. This broadcast can be used as a trigger for other behaviors.</td></tr><tr><td>Animation</td><td>Select an animation for the player to execute from the dropdown list</td></tr><tr><td>Reset Automatically</td><td>Toggle button that specifies whether the player animation must reset</td></tr></tbody></table>

### Accessing the Play Player Animation Logic Template using T\#

If you want to further customize this logic template, you can do so by accessing its T# Wrapper -  [PlayPlayerAnimationTemplate](../../coding-using-t/t-logic-template-wrappers.md#playplayersanimationtemplate). You may also find the wrapper - [PlayerAnimationControlTemplate](../../coding-using-t/t-logic-template-wrappers.md#playeranimationcontroltemplate) useful

# Stop Animation

The Stop Animation logic template is used for animated objects. When executed, it halts the current animation of the object.

To add the Stop Animation logic template to an asset, follow these steps:

1. Go to the Logic Tab.
2. Select Stop Animation under the header "Effects".
3. Drag and drop it onto the desired asset.

You can edit the following parameters of this template directly through the scene editor:

<table><thead><tr><th width="279">Parameters</th><th>Description</th></tr></thead><tbody><tr><td>Stop When</td><td><p></p><p>Choose from the following options in the dropdown menu for when the animation should be stopped:</p><ol><li>On Player Touch</li><li>On Other Object Touch</li><li>On Click</li><li>On Broadcast: If selected, specify the broadcast to listen to.</li></ol></td></tr><tr><td>Broadcast</td><td>Enter a broadcast to be generated at the end of execution. This broadcast can be used as a trigger for other behaviors.</td></tr></tbody></table>

### Accessing the Stop Animation Logic Template using T\#

There are currently no available T# Wrappers for this template.


# Stop Rotate

Stop Rotate allows you to stop the rotation of any object by attaching the behaviour to it and defining any trigger to initiate the event.

| Parameters  | Type                                                                                     |
| ----------- | ---------------------------------------------------------------------------------------- |
| Start Event | other object touches, mouse clicked, broadcast listened                                  |
| Effects     | Change in an Asset's Orientation, Generate a Broadcast Signal, Enable an SFX or Particle |
| Type        | dependent                                                                                |

To add the Stop Rotate behavior to an asset, follow these steps:

1. Select the asset you wish to apply the Stop Rotate behavior to.
2. In the Inspector panel, click on **Add Behavior**.
3. From the list of behaviors, choose **Stop Rotate.**

You can customize the below-mentioned parameters according to your requirements:

<table><thead><tr><th width="268">Parameters</th><th>Description</th></tr></thead><tbody><tr><td>StopWhen</td><td>You can choose the trigger on which the object will stop rotating. These are:<br>- After a broadcast message has been received by the object.<br>- When a different object touches the object<br>- When you click on the object.<br></td></tr><tr><td>Broadcast Data</td><td>Define a broadcast that can be used as a trigger for any other behavior. <br>The broadcast is sent when object stops rotating</td></tr><tr><td>Play SFX</td><td>Choose a sound effect to play when the object stops rotating.</td></tr><tr><td>Play VFX</td><td>Choose a visual effect to play when the object stops rotating.</td></tr></tbody></table>

### Accessing the Stop Rotate Logic Template using T\#

There are currently no available T# Wrappers for this template.

# ShowUI

The ShowUI behavior allows the creator to display UI elements on the screen in response to player interactions with game objects.

To add the Show UI logic template to an asset, follow these steps:

1. Go to the Logic Tab.
2. Select Show UI Animation under the header "Effects".
3. Drag and drop it onto the desired asset.

You can edit the following parameters of this template directly through the scene editor:

<table><thead><tr><th width="236">Parameters</th><th>Description</th></tr></thead><tbody><tr><td>Show On</td><td><p></p><p>Choose from the following options in the dropdown menu for when the UI Needs to be displayed:</p><ol><li>On Game Start</li><li>On Player Touch</li><li>On Other Object Touch</li><li>On Click</li><li>On Broadcast: If selected, specify the broadcast to listen to.</li></ol></td></tr><tr><td>Animation</td><td>CHoose the animation for the UI element</td></tr><tr><td>Screen Position</td><td>Choose from the dropdown  the position of the UI element</td></tr><tr><td>UI Template</td><td>Select from a list of pre-available UI Templates</td></tr><tr><td>Animation Duration</td><td>Specify the duration of Animation in seconds</td></tr><tr><td>Show for</td><td>Specify the duration for which the UI must be displayed</td></tr><tr><td>Broadcast Data</td><td>Choose to enter a broadcast that can be used as a trigger for any other behavior. <br>The broadcast is sent when the UI is displayed</td></tr></tbody></table>



Terra Studio has pre-defined UI Templates as shown in [`ShowUI Prefabs`](showui-prefabs.md).&#x20;

# ShowUI Prefabs

ShowUI offers a wide selection of pre-defined UI layouts that can be used to display a UI in your game. You can choose any UI from the dropdown menu under "UI To Show." The name and layout of each UI are provided in the "Available UI Prefabs" table below. Each layout contains two types of elements:

* **Editable Text**: You can include up to three text elementsText 1, Text 2, and Text 3. You can directly input the desired text in these fields.
* **Icons**: You can use up to two iconsIcon 1 and Icon 2. To access or modify an icon, simply input the icon's name from the list of available [ShowUI Icons](show-ui-icons.md).

For a complete guide on adding UI elements, refer to the [ShowUI](./) documentation.

### Available UI Prefabs

The table below displays the layout and positioning of Icon 1, Icon 2, Text 1, Text 2, and Text 3 for each prefab. Choose a layout from the dropdown menu under "UI To Show."

| UI To Show                   | UI Layout                                                                     |
| ---------------------------- | ----------------------------------------------------------------------------- |
| PaperBoy Level 1 Toasts      | ![](<../../../../.gitbook/assets/Screenshot 2024-02-07 at 8.01.24PM.png>)    |
| PaperBoy Level 1 End Screens | ![](<../../../../.gitbook/assets/Screenshot 2024-02-07 at 8.01.17PM.png>)    |
| PaperBoy Level 2 Tutorials   | ![](<../../../../.gitbook/assets/Screenshot 2024-02-07 at 8.01.31PM.png>)    |
| PaperBoy Upgrade             | ![](<../../../../.gitbook/assets/Screenshot 2024-02-07 at 8.01.37PM.png>)    |
| TankRush Blue Box            | ![](<../../../../.gitbook/assets/Screenshot 2024-02-07 at 8.01.45PM.png>)    |
| Tank Rush Blue Popup         | ![](<../../../../.gitbook/assets/Screenshot 2024-02-07 at 8.01.47PM.png>)    |
| Tank Rush Red Popup          | ![](<../../../../.gitbook/assets/Screenshot 2024-02-07 at 8.01.51PM.png>)    |
| Tank Rush Yellow Box         | ![](<../../../../.gitbook/assets/Screenshot 2024-02-07 at 8.01.54PM.png>)    |
| Tank Rush Yellow Popup       | ![](<../../../../.gitbook/assets/Screenshot 2024-02-07 at 8.01.57PM.png>)    |
| Animal Run Whoops            | ![](<../../../../.gitbook/assets/Screenshot 2024-02-12 at 7.05.22PM.png>)    |
| Animal Run Intro             | ![](<../../../../.gitbook/assets/Screenshot 2024-02-12 at 7.05.17PM.png>)    |
| Animal Run New Level         | ![](<../../../../.gitbook/assets/Screenshot 2024-02-12 at 7.05.11PM.png>)Pap |


# Show UI Icons

When a ShowUI behavior includes an icon (either Icon 1 or Icon 2), you can choose the desired icon for that position by entering its name according to the following table.

| Icon Name     | Icon Appearance                                                            |
| ------------- | -------------------------------------------------------------------------- |
| PB\_Magnet    | ![](<../../../../.gitbook/assets/Screenshot 2024-02-07 at 8.17.46PM.png>) |
| PB\_Shop      | ![](<../../../../.gitbook/assets/Screenshot 2024-02-07 at 8.17.49PM.png>) |
| PB\_Reckless  | ![](<../../../../.gitbook/assets/Screenshot 2024-02-07 at 8.17.47PM.png>) |
| PB\_Jump      | ![](<../../../../.gitbook/assets/Screenshot 2024-02-07 at 8.17.44PM.png>) |
| PB\_Extreme   | ![](<../../../../.gitbook/assets/Screenshot 2024-02-07 at 8.17.42PM.png>) |
| PB\_Delivered | ![](<../../../../.gitbook/assets/Screenshot 2024-02-07 at 8.17.40PM.png>) |
| PB\_Carrot    | ![](<../../../../.gitbook/assets/Screenshot 2024-02-07 at 8.17.36PM.png>) |
| PB\_Coin      | ![](<../../../../.gitbook/assets/Screenshot 2024-02-07 at 8.17.38PM.png>) |
| AR\_Lock      | ![](<../../../../.gitbook/assets/Screenshot 2024-02-12 at 7.08.08PM.png>) |



# Overall Game

<table><thead><tr><th width="259">Logic Template</th><th>Description</th></tr></thead><tbody><tr><td><a href="checkpoint.md">Checkpoint</a></td><td>Restarts the game from a specific point if you fail a challenge or lose a life</td></tr><tr><td><a href="update-timer.md">Update Timer</a></td><td>Updates the timer  to a new specified value</td></tr><tr><td><a href="reset-timer.md">Reset Timer</a></td><td>Resets the timer to zero</td></tr><tr><td><a href="load-scene.md">Load Scene</a></td><td>Loads a New Scene</td></tr><tr><td><a href="random-level-selector.md">Random Level Selector</a></td><td>Loads a random new scene on game start instead of the default scene</td></tr><tr><td><a href="studio-machine.md">Studio Machine</a></td><td>Enables you to add custom T# scripts to an asset</td></tr></tbody></table>

# Reset Timer

The Reset Timer behavior resets the game timer to its initial value without affecting the game experience. If it's a countdown timer, the time is reset to the starting value. If it's a count-up timer, the time is reset to 0 seconds.

You can customize the template parameters according to the game requirements:

To add the Reset Timer logic template, follow these steps:

1. Go to the Logic Tab.
2. Select Reset Timer under the header "Game".
3. Drag and drop it onto the desired asset.



You can edit the following parameters of this template directly through the scene editor interface:

<table><thead><tr><th width="318">Parameters</th><th>Description</th></tr></thead><tbody><tr><td>Reset When</td><td><p>Select a trigger from the dropdown to activate the logic template:</p><ul><li><strong>Player Touches</strong>: Resets the timer when the player touches the selected object.</li><li><strong>Other Object Touches</strong>: Resets the timer when another object touches the selected object.</li><li><strong>Clicked</strong>: Resets the timer when you click the selected object.</li><li><strong>Broadcast Listened</strong>: Resets the timer when it receives a broadcast</li></ul></td></tr><tr><td>Broadcast</td><td> Define a broadcast to be generated that can trigger other actions. The broadcast is sent when the timer is reset.</td></tr></tbody></table>

## Accessing the Reset Timer Template using T\#

Currently, there's no T# Wrapper available to customize this logic template beyond the scene editor's capabilities. However, you can write your own code in T# to implement this logic from scratch.

# Studio Machine

The Studio Machine Template lets you attach custom T# scripts to Assets. This template provides the coding flexibility needed to enable an Asset to interact however you want using T# Code.

To add the Studio Machine Template, follow these steps:

1. Go to the Logic Tab.
2. Select Studio Machine under the "Game" Header
3. Drag and drop it onto the desired asset.

Once you add Studio Machine to an Asset, you will notice that the Advanced Mode Inspector panel shows a Script Tab and an Object Variable Tab. \


<table><thead><tr><th width="264">Parameter</th><th>Description</th></tr></thead><tbody><tr><td>Script</td><td><p></p><p>Select the script to execute from the dropdown list of all T# scripts you have created in the Scripts Tab. You can add only one script to an Asset</p></td></tr><tr><td>Object Variables</td><td>Define object variables like String, Int, Float, and Game Objects. These can be locally referenced in the Scripts attached to the Asset. Only variables declared here can be accessed by the script attached to the Asset.</td></tr></tbody></table>

You can know more about how exactly to add custom scripts here:&#x20;

[T# Basics](../../coding-using-t/t-basics.md)

[T# Logic Template Wrappers](../../coding-using-t/t-logic-template-wrappers.md)

# Random Level Selector

The Random Level Selector Logic Template allows you to randomly load a scene from a list of predefined scenes. It is different from the Load Scene Logic Template because here the scene is chosen randomly from a list of multiple scenes

To add the Random Level Selector logic template, follow these steps:

1. Go to the Logic Tab.
2. Select Random Level Selector.
3. Drag and drop it onto the desired asset.

You can thentailor the following parameters in Advanced Mode to match your needs:

<table><thead><tr><th width="264">Parameter</th><th>Description</th></tr></thead><tbody><tr><td>When</td><td><p></p><p>Select When to Load a Random Level from a dropdown<strong>:</strong></p><ul><li>On Game Start</li><li>On Broadcast Listened</li></ul></td></tr><tr><td>Scenes</td><td>Add a selection of scenes to randomly choose from for loading.</td></tr></tbody></table>

## Accessing the Random Level Selector Template using T\#

Currently, there's no T# Wrapper available to customize this logic template beyond the scene editor's capabilities. However, you can write your own code in T# to implement this logic from scratch.

# Update Timer

In the game, significant events such as completing tasks or defeating enemies can adjust the timer, adding bonus time or starting time-limited challenges. Conversely, mistakes or failures can reduce the time. The Update Timer template is used to handle these changes.

To add the Update Timer logic template, follow these steps:

1. Go to the Logic Tab.
2. Select Update Timer under the header "Game".
3. Drag and drop it onto the desired asset.

You can edit the following parameters of this template directly through the scene editor interface:

<table><thead><tr><th width="282">Parameters</th><th>Description</th></tr></thead><tbody><tr><td>Update When</td><td><p></p><p>Select a trigger from the dropdown to activate the logic template:</p><ul><li><strong>Player Touches</strong>: Resets the timer when the player touches the selected object.</li><li><strong>Other Object Touches</strong>: Resets the timer when another object touches the selected object.</li><li><strong>Clicked</strong>: Resets the timer when you click the selected object.</li><li><strong>Broadcast Listened</strong>: Resets the timer when it receives a broadcast</li></ul></td></tr><tr><td>Operation</td><td>Define the operator that will modify the timer. Four operators are allowed - Add, Subtract, Multiply and Divide</td></tr><tr><td>Update By</td><td>The quantity specified in this context will determine the extent to which the timer is modified.</td></tr><tr><td>Sound Effect on Start</td><td>Choose a sound effect to play when the timer value is updated.</td></tr><tr><td>Visual Effect on Start</td><td>Choose a visual effect to play when the timer value is updated.</td></tr><tr><td>Broadcast on Update</td><td>Choose to enter a broadcast that can be used as a trigger for any other behavior. <br>The broadcast is sent when the timer is updated.</td></tr><tr><td>Execute always</td><td>This toggle, when activated, will always execute this. When off, it will execute it only once.</td></tr></tbody></table>

## Accessing the Update Timer Template using T\#

If you want to further customize this logic template, you can do so by accessing its T# Wrapper - [UpdateTimerTemplate](../../coding-using-t/t-logic-template-wrappers.md#updatetimertemplate). &#x20;


# Checkpoint

A checkpoint is a designated spot where player progress is saved automatically or manually. These markers allow you to restart the game from that specific point if you fail a challenge, lose a life, or need to pause the game.

To add the checkpoint logic template, follow these steps:

1. Go to the Logic Tab.
2. Select Checkpoint under the header "Game".
3. Drag and drop it onto the desired asset.

You can edit the following parameters of this template directly through the scene editor interface:

| Parameter     | Description                                                                                                                                               |
| ------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Play SFX      | Choose a short chime to play when you arrive at checkpoint                                                                                                |
| Play VFX      | Choose a visual effect to play when you arrive at the checkpoint                                                                                          |
| BroadcastData | <p>Choose to enter a broadcast that can be used as a trigger for any other behavior. <br>The broadcast is sent when the you arrive at the checkpoint.</p> |

## Accessing the Checkpoint Template using T\#

If you want to further customize this logic template, you can do so by accessing its T# Wrapper - [CheckpointTemplate](../../coding-using-t/t-logic-template-wrappers.md#checkpointtemplate).&#x20;

# Load Scene

The Load Scene logic template enables you to transition from one game environment (scene)  to another, such as progressing from one level to the next or exploring a new area.&#x20;

To add the Load Scene logic template, follow these steps:

1. Go to the Logic Tab.
2. Select Load Scene under the header "Game".
3. Drag and drop it onto the desired asset.

You can customize the below-mentioned parameters according to your requirements:

<table><thead><tr><th width="264">Parameter</th><th>Description</th></tr></thead><tbody><tr><td>Load Scene When</td><td><p></p><p>Choose from this dropdown when to transition to a different scene:</p><ul><li><strong>Broadcast Listened</strong>: After the object receives a broadcast message.</li><li><strong>Player Touch</strong>: When the player touches the object.</li><li><strong>Other Object Touch</strong>: When another object touches the object.</li><li><strong>Clicked</strong>: When you click on the object.</li></ul></td></tr><tr><td>Scenes to Load</td><td>Click the + button to choose the next scene to load when the trigger condition is met. It displays a list of all available scenes in the game.</td></tr><tr><td>Can Repeat Previous Level</td><td>Toggle that specifies whether the player can repeat the previous level</td></tr></tbody></table>

## Accessing the Load Scene Template using T\#

Currently, there's no T# Wrapper available to customize this logic template beyond the scene editor's capabilities. However, you can write your own code in T# to implement this logic from scratch.



# T# StudioController Wrappers

The StudioController class represents a controller for the player in the game. It provides various functionalities to interact with and manipulate the player character's properties and behaviors.

#### Method: **GetMyController**

Retrieves the current player's StudioController.

```csharp
StudioController myController = StudioController.GetMyController();
```

#### Method: **CheckIfController**

Checks if a given GameObject has an associated StudioController.

```csharp
StudioController controller = StudioController.CheckIfController(gameObject);
```

#### Property: **IsMoving**

Checks if the player is moving.

```csharp
bool isMoving = StudioController.GetMyController().IsMoving();
```

#### Property: **GetPlayerPosition**

Gets the player's current position.

```csharp
Vector3 playerPosition = StudioController.GetMyController().GetPlayerPosition();
```

#### Property: **SetPlayerPosition**

Sets the player's position with optional smooth movement and camera transition.

```csharp
StudioController.GetMyController().SetPlayerPosition(new Vector3(0, 0, 0), smoothMove: true, smoothCamera: true);
```

#### Property: **GetPlayerForward**

Gets the forward direction of the player.

```csharp
Vector3 forwardDirection = StudioController.GetMyController().GetPlayerForward();
```

#### Property: **SetPlayerRotation**

Sets the player's rotation.

<pre class="language-csharp"><code class="lang-csharp"><strong>StudioController.GetMyController().SetPlayerRotation(Quaternion.identity);
</strong></code></pre>

#### Property: **GetOverHeadLocator**

Gets the transform of the overhead locator.

```csharp
Transform overHeadLocator = StudioController.GetMyController().GetOverHeadLocator();
```

#### Property: **GetControllerCamera**

Gets the camera associated with the player controller.

```csharp
Camera controllerCamera = StudioController.GetMyController().GetControllerCamera();
```

#### Property: **ResetCameraCurrentPosition**

Resets the camera to its current position.

```csharp
controller.ResetCameraCurrentPosition();
```

#### Property: **GetLocator**

Finds and returns a transform based on a given locator name.

```csharp
Transform locator = StudioController.GetMyController().GetLocator("locatorName");
```

#### Property: **GetPlayerData**

Returns the underlying player data associated with this controller.

```csharp
IPlayerData playerData = StudioController.GetMyController().GetPlayerData();
```

#### Property: **GetLocatorEnumBased**

Gets the transform of a location based on the PlayerLocEnum.

```csharp
Transform locatorEnumBased = StudioController.GetMyController().GetLocatorEnumBased(PlayerLocEnum.LeftLegWingLoc);
```

The avaliable locators for `PlayerLocEnum` are as follows:&#x20;

```
{
    LeftLegWingLoc,
    LeftLegGreavesLoc,
    RightLegWingLoc,
    RightLegGreavesLoc,
    LeftLGlovesLoc,
    LeftLowerArmLoc,
    LeftShoulderLoc,
    LeftShoulderArmourLoc,
    HaloLoc,
    EyewearLoc,
    RightEarWearLoc,
    HeadWearLoc,
    MaskLoc,
    LeftEarWearLoc,
    CamLoc,
    ShootIKLoc,
    RightPalmLoc,
    RightGlovesLoc,
    RightLowerArmLoc,
    RightShoulderLoc,
    RightShoulderArmourLoc,
    WeaponLoc,
    BackLoc,
    NeckLoc,
    PetLoc,
    LegendaryPetLoc,
    ShoulderPetLoc,
    BaseLoc
}
```

---
description: While T# is pretty similar to C#, somethings don't work the same
---

# What not to do on T\#

#### Things that do not work at all currently

1. Any form of Generic GetComponent\<T> or similar in which T is not defined in the game assembly. All of these have non generic working alternatives except AddComponent.
   1. `GetComponent<T>`
   2. `GetComponents<T>`
   3. `AddComponent<T> // even the non generic one isn't allowed currently`
   4. `FindObjectOfType<T>`
   5. `FindObjectsOfType<T>`
   6. `GetComponentInParent<T>`
   7. `GetComponentsInParent<T>`
   8. `GetComponentInChildren<T>`
   9. `GetComponentsInChildren<T>`
2. Enumerable on Transform
   1. This is a problem currently in interpreter. We can ask for a fix or try fixing ourselves.
   2. Can be overcome by using a for loop, in combination with `transform.childCount` and `transform.GetChild(i)`
3. foreach loops
   1. Foreach loops are currently disabled.
4. Lambdas, delegates, Actions, Events, Funcs, UnityEvents
   1. The generic versions are the problem mostly. I don't think these are solvable unless (read : next section Pt1)
   2. The non generic ones need to be tested.
5. Unboxing.
   1. This is a problem currently in interpreter. We can ask for a fix or try fixing ourselves. An actual fix might not be possible however due to language limitations. Unsure.
   2. Ex : `object boxedVal = (int)3; //no problem int failingUnboxedVal = (int)boxedVal; //doesn't work int workingUnboxedVal = Convert.ToInt32(boxedVal); //works`
6. Calling GetComponent instantly after Instantiate call
   1. Because of the current structure. Can be fixed with a change in structure.
   2. The parallel mono is actually created whenever the Start of any script on an object is called. If you use `GetComponent()` instantly after Instantiate, the mono does not exist yet.
7. SerializedFields
   1. They arent currently supported.
   2. The alternative is to use, ObjectVariables which is a component that gets auto added on every object which has a `TerraMachine`. You can add any `GameObject` references to this, and access them from a script using `GetObjectVariable(key)` and `SetObjectVariable(key)`
8. Turning Event Functions Into Coroutines
   1. In normal Unity, you can use `IEnumerator Start()` and make your Start function act as a coroutine. This is not possible with interpreter currently.
9. Obvious things that will not behave as expected however shouldnt be required by games
   1. `async` code
   2. `Tasks`
   3. Anything related to `GetType()` or `typeof()`

---
description: >-
  List of the properties, events and methods wrappers available for each logic
  template
---

# T# Logic Template Wrappers

## AdvanceMoveTemplate

This template manages advanced movement for entities using the `TranslateComponent`, handling speed and event management for ping-pong actions. To integrate the `AdvanceMoveTemplate`, follow the usage instructions below:

```csharp
AdvanceMoveTemplate template = (GetTemplate(typeof(AdvanceMoveTemplate)) as AdvanceMoveTemplate);
```

### Property: <mark style="color:yellow;">`Speed`</mark>

Used for Getting and Setting the Movement Speed

```csharp
float speed = template.Speed; // Getting the speed
template.Speed = 5.0; // Setting the speed
```

### Event: <mark style="color:yellow;">`Bla`</mark>

Used to Managing the Ping-Pong Event. To subscribe or unsubscribe from the ping-pong event:

```csharp
template.Bla += OnPingPongAction; // Subscribe to the event
template.Bla -= OnPingPongAction; // Unsubscribe from the event

void OnPingPongAction()
{
    // Handle ping-pong action here
}
```

## ChangeMagnetTemplate

This template manages the magnet range for entities using the `ChangeMagnetComponent`, allowing customization of magnet range behavior within your game. Integrate `ChangeMagnetTemplate` as follows:

```csharp
ChangeMagnetTemplate template = (GetTemplate(typeof(ChangeMagnetTemplate)) as ChangeMagnetTemplate);
```

### Property: <mark style="color:yellow;">`MagnetRange`</mark>

To get or set the magnet range:

```csharp
float magnetRange = template.MagnetRange; // Getting the magnet range
template.MagnetRange = 10.0; // Setting the magnet range
```

## ChangeMaterialPropertyTemplate

This template provides functionality to change material properties on a game object. It can be accessed and utilized as follows:

```csharp
ChangeMaterialPropertyTemplate template = (GetTemplate(typeof(ChangeMaterialPropertyTemplate)) as ChangeMaterialPropertyTemplate);
```

### Property: <mark style="color:yellow;">`Channels`</mark>

Access the changed material channels array.

```csharp
ChangeMaterialPropertyTemplate template = (GetTemplate(typeof(ChangeMaterialPropertyTemplate)) as ChangeMaterialPropertyTemplate);
ChangedMaterialChannel[] channels = template.Channels; // Gets the changed material channels array
```

### Property: <mark style="color:yellow;">`Length`</mark>

Get the number of channels.

```csharp
ChangeMaterialPropertyTemplate template = (GetTemplate(typeof(ChangeMaterialPropertyTemplate)) as ChangeMaterialPropertyTemplate);
int length = template.Length; // Gets the number of channels
```

### Property: <mark style="color:yellow;">`Indexer`</mark>

**Getting a Channel by Index**

```csharp
ChangeMaterialPropertyTemplate template = (GetTemplate(typeof(ChangeMaterialPropertyTemplate)) as ChangeMaterialPropertyTemplate);
ChangedMaterialChannel channel = template[0]; // Gets the first channel
```

**Setting a Channel by Index**

```csharp
ChangeMaterialPropertyTemplate template = (GetTemplate(typeof(ChangeMaterialPropertyTemplate)) as ChangeMaterialPropertyTemplate);
template[0] = new ChangedMaterialChannel(); // Sets the first channel
```

### Event: <mark style="color:yellow;">`OnMaterialChanged`</mark>

**Subscribing to the Event**

```csharp
ChangeMaterialPropertyTemplate template = (GetTemplate(typeof(ChangeMaterialPropertyTemplate)) as ChangeMaterialPropertyTemplate);
template.OnMaterialChanged += HandleMaterialChanged;

void HandleMaterialChanged(int index)
{
    // Handle the material change
}
```

**Unsubscribing from the Event**

```csharp
ChangeMaterialPropertyTemplate template = (GetTemplate(typeof(ChangeMaterialPropertyTemplate)) as ChangeMaterialPropertyTemplate);
template.OnMaterialChanged -= HandleMaterialChanged;
```

### Method: <mark style="color:yellow;">`CheckIndex`</mark>

Ensure the index is within the valid range of channels.

```csharp
template.CheckIndex(index);
```

### Method: <mark style="color:yellow;">`GetEnumerator`</mark>

Get an enumerator for iterating through the channels.

```csharp
IEnumerator enumerator = template.GetEnumerator();
while (enumerator.MoveNext())
{
    ChangedMaterialChannel channel = (ChangedMaterialChannel)enumerator.Current;
    // Process the channel
}
```

## ChangePlayerSpeedTemplate

This template provides functionality to change the player speed on a game object. It can be accessed and utilized as follows:

```csharp
ChangePlayerSpeedTemplate template = (GetTemplate(typeof(ChangePlayerSpeedTemplate)) as ChangePlayerSpeedTemplate);
```

### **Property: **<mark style="color:yellow;">**`Modifier`**</mark>

Get or set the speed modifier (increase or decrease)

```csharp
ChangePlayerSpeedTemplate template = (GetTemplate(typeof(ChangePlayerSpeedTemplate)) as ChangePlayerSpeedTemplate);
ChangePlayerSpeed.Modifier modifier = template.Modifier; // Gets the modifier
template.Modifier = ChangePlayerSpeed.Modifier.Increase; // Sets the modifier
```

### **Property: **<mark style="color:yellow;">**`PlayerSpeed`**</mark>

Get or set the player speed.

```csharp
ChangePlayerSpeedTemplate template = (GetTemplate(typeof(ChangePlayerSpeedTemplate)) as ChangePlayerSpeedTemplate);
float playerSpeed = template.PlayerSpeed; // Gets the player speed
template.PlayerSpeed = 10.0f; // Sets the player speed
```

### **Event: **<mark style="color:yellow;">**`OnPlayerSpeedChanged`**</mark>

**Subscribing to the Event**

```csharp
ChangePlayerSpeedTemplate template = (GetTemplate(typeof(ChangePlayerSpeedTemplate)) as ChangePlayerSpeedTemplate);
template.OnPlayerSpeedChanged += HandlePlayerSpeedChanged;

void HandlePlayerSpeedChanged(float newSpeed)
{
    // Handle the player speed change
}
```

**Unsubscribing from the Event**

```csharp
ChangePlayerSpeedTemplate template = (GetTemplate(typeof(ChangePlayerSpeedTemplate)) as ChangePlayerSpeedTemplate);
template.OnPlayerSpeedChanged -= HandlePlayerSpeedChanged;
```

## CheckpointTemplate

This template provides functionality to manage checkpoint events in the game. You access it by&#x20;

```csharp
CheckpointTemplate template = (GetTemplate(typeof(CheckpointTemplate)) as CheckpointTemplate);
```

### Event: <mark style="color:yellow;">`OnCheckpointTouched`</mark>

#### Subscribing to the Event

To subscribe to the `OnCheckPointTouched` event:

```csharp
CheckpointTemplate template = (GetTemplate(typeof(CheckpointTemplate)) as CheckpointTemplate);
template.OnCheckPointTouched += MyMethod; // Subscribe MyMethod to the event
```

#### Unsubscribing from the Event

To unsubscribe from the `OnCheckPointTouched` event:

```csharp
CheckpointTemplate template = (GetTemplate(typeof(CheckpointTemplate)) as CheckpointTemplate);
template.OnCheckPointTouched -= MyMethod; // Unsubscribe MyMethod from the event
```

## CollectableTemplate

This template provides functionality to manage collectable items in the game. To access the `CollectableTemplate`, use the following code:

```csharp
CollectableTemplate template = (GetTemplate(typeof(CollectableTemplate)) as CollectableTemplate);
```

### Property: <mark style="color:yellow;">`ScoreGroup`</mark>

#### Getting the Score Group

To get the score group associated with the collectable item:

```csharp
string scoreGroup = template.ScoreGroup;
```

#### Setting the Score Group

To set the score group for the collectable item:

```csharp
template.ScoreGroup = "NewScoreGroup";
```

### Property: <mark style="color:yellow;">`Score Property`</mark>

#### Getting the Score Value

To get the score value of the collectable item:

```csharp
int score = template.Score;
```

#### Setting the Score Value

To set the score value for the collectable item:

```csharp
template.Score = 100;
```

### Event: <mark style="color:yellow;">`OnCollected`</mark>

#### Subscribing to the Event

To subscribe to the `OnCollected` event:

```csharp
template.OnCollected += MyMethod; // Subscribe MyMethod to the event
```

#### Unsubscribing from the Event

To unsubscribe from the `OnCollected` event:

```csharp
template.OnCollected -= MyMethod; // Unsubscribe MyMethod from the event
```

## DelayBroadcastTemplate

This template manages delayed broadcast functionality in the game. To access the `DelayBroadcastTemplate`, use the following code:

```csharp
DelayBroadcastTemplate template = (GetTemplate(typeof(DelayBroadcastTemplate)) as DelayBroadcastTemplate);
```

### Property: <mark style="color:yellow;">`Delay`</mark>

#### Getting the Delay Time

To get the delay time configured for the broadcast:

```csharp
float delayTime = template.Delay;
```

#### Setting the Delay Time

To set the delay time for the broadcast:

```csharp
template.Delay = 2.5; // Example: set delay time to 2.5 seconds
```

## DestroyOnTemplate

This template manages the behavior of objects that are destroyed after a specified delay. To access the `DestroyOnTemplate`, use the following code:

```csharp
DestroyOnTemplate template = (GetTemplate(typeof(DestroyOnTemplate)) as DestroyOnTemplate);
```

### Property: <mark style="color:yellow;">`DestroyAfter`</mark>

#### Getting the Destruction Delay

To get the delay after which the object is destroyed:

```csharp
float destroyAfter = template.DestroyAfter;
```

#### Setting the Destruction Delay

To set the delay after which the object should be destroyed:

```csharp
template.DestroyAfter = 5.0; // Example: set destruction delay to 5 seconds
```

## DestroyTemplate

This template manages the behavior of objects that are destroyed after a specified delay.  To access the `DestroyTemplate`, use the following code:

```csharp
DestroyTemplate template = (GetTemplate(typeof(DestroyTemplate)) as DestroyTemplate);
```

### Property: <mark style="color:yellow;">`DestroyAfter`</mark>

#### Getting the Destruction Delay

To get the delay after which the object is destroyed:

```csharp
float destroyAfter = template.DestroyAfter;
```

#### Setting the Destruction Delay

To set the delay after which the object should be destroyed:

```csharp
template.DestroyAfter = 5.0; // Example: set destruction delay to 5 seconds
```

## GameProgressTemplate

This template manages game progress functionality in the game. To access the GameProgressTemplate, use the following code:

```csharp
GameProgressTemplate template = (GetTemplate(typeof(GameProgressTemplate)) as GameProgressTemplate);
```

### Property: <mark style="color:yellow;">`CurrentProgress`</mark>

**Getting Current Progress**

To get the current progress:

```csharp
int currentProgress = template.CurrentProgress;
```

### Property: <mark style="color:yellow;">`LerpSpeed`</mark>

**Getting the Lerp Speed**

To get the lerp speed configured for the progress bar:

```csharp
float lerpSpeed = template.LerpSpeed;
```

**Setting the Lerp Speed**

To set the lerp speed for the progress bar:

```csharp
template.LerpSpeed = 1.0f; // Example: set lerp speed to 1.0
```

### Property: <mark style="color:yellow;">`BroadcastOnEveryProgress`</mark>

**Getting the Broadcast On Every Progress**

To get the broadcast trigger configured for each progress point:

```csharp
string broadcastOnEveryProgress = template.BroadcastOnEveryProgress;
```

**Setting the Broadcast On Every Progress**

To set the broadcast trigger for each progress point:

```csharp
template.BroadcastOnEveryProgress = "progress_event"; // Example: set broadcast trigger
```

### Property: <mark style="color:yellow;">`BroadcastOnComplete`</mark>

**Getting the BroadcastOnComplete**

To get the broadcast trigger configured for completion:

```csharp
string broadcastOnComplete = template.BroadcastOnComplete;
```

**Setting the BroadcastOnComplete**

To set the broadcast trigger for completion:

```csharp
template.BroadcastOnComplete = "completion_event"; // Example: set broadcast trigger
```

## GameScoreTemplate

This template manages in-game scoring functionality. To access the GameScoreTemplate, use the following code:

```csharp
GameScoreTemplate template = (GetTemplate(typeof(GameScoreTemplate)) as GameScoreTemplate);
```

### Property: <mark style="color:yellow;">`CurrentScore`</mark>

**Getting Current Score**

To get the current score:

```csharp
int currentScore = template.CurrentScore;
```

### Property: <mark style="color:yellow;">`BestScore`</mark>

**Getting Best Score**

To get the best score achieved:

```csharp
int bestScore = template.BestScore;
```

### Property: <mark style="color:yellow;">`IsScoreUIShown`</mark>

To check if the score UI is currently displayed:

```csharp
bool isScoreUIShown = template.IsScoreUIShown;
```

### Property: <mark style="color:yellow;">`IsBestScoreCalculated`</mark>

**Checking if Best Score Calculation is Enabled**

To check if the best score calculation is enabled:

```csharp
bool isBestScoreCalculated = template.IsBestScoreCalculated;
```

### Event: <mark style="color:yellow;">`OnScoreModified`</mark>

**Subscribing to OnScoreModified Event**

To subscribe to the score modification event:

```csharp
template.OnScoreModified += OnScoreModifiedHandler;
```

**Unsubscribing from OnScoreModified Event**

To unsubscribe from the score modification event:

<pre class="language-csharp"><code class="lang-csharp">template.OnScoreModified -= OnScoreModifiedHandler;
void OnScoreModifiedHandler(int modifiedScore)
        {
                // Handle score modification
<strong>        }
</strong></code></pre>

## GrowTemplate

This template manages growth and scale behavior of objects n the game. To access the GrowTemplate, use the following code:

```csharp
GrowTemplate template = (GetTemplate(typeof(GrowTemplate)) as GrowTemplate);
```

### Property: <mark style="color:yellow;">`ScaleTo`</mark>

**Getting and Setting Scale To**

To get or set the scale to which the object grows:

```csharp
Vector3 scaleTo = template.ScaleTo;
template.ScaleTo = new Vector3(2f, 2f, 2f); // Example of setting scale
```

### Property: <mark style="color:yellow;">`Speed`</mark>

**Getting and Setting Growth Speed**

To get or set the speed at which the object grows:

```csharp
float speed = template.Speed;
template.Speed = 1.5f; // Example of setting speed
```

### Property: <mark style="color:yellow;">`ShouldPingPong`</mark>

**Checking and Setting Ping Pong Behavior**

To check or set whether the growth should ping pong (alternate between scaling up and scaling down):

```csharp
bool shouldPingPong = template.ShouldPingPong;
template.ShouldPingPong = true; // Example of enabling ping pong behavior
```

### Property: <mark style="color:yellow;">`RepeatForever`</mark>

**Checking and Setting RepeatForever**

To check or set whether the growth should repeat indefinitely:

```csharp
bool repeatForever = template.RepeatForever;
template.RepeatForever = true; // Example of enabling repeat forever
```

### Property: <mark style="color:yellow;">`RepeatFor`</mark>

**Getting and Setting Repeat Duration**

To get or set the duration for which the growth should repeat:

```csharp
int repeatFor = template.RepeatFor;
template.RepeatFor = 10; // Example of setting repeat duration
```

### Event: <mark style="color:yellow;">`OnRepetationOver`</mark>

**Subscribing to OnRepetationOver Event**

To subscribe to the event triggered when the repetition is over:

```csharp
template.OnRepetationOver += OnRepetationOverHandler;
```

**Unsubscribing from OnRepetationOver Event**

To unsubscribe from the event triggered when the repetition is over:

```csharp
template.OnRepetationOver -= OnRepetationOverHandler;
void OnRepetationOverHandler()
{
    // Handle repetition over event
}
```

### Event: <mark style="color:yellow;">`OnGrowFinished`</mark>

**Subscribing to OnGrowFinished Event**

To subscribe to the event triggered when the growth is finished:

```csharp
template.OnGrowFinished += OnGrowFinishedHandler;
```

**Unsubscribing from OnGrowFinished Event**

To unsubscribe from the event triggered when the growth is finished:

```csharp
template.OnGrowFinished -= OnGrowFinishedHandler;
```

```csharp
void OnGrowFinishedHandler()
{
    // Handle growth finished event
}
```

## InGameTimerTemplate

This template manages in-game timer functionality. To access the InGameTimerTemplate, use the following code:

```csharp
InGameTimerTemplate template = (GetTemplate(typeof(InGameTimerTemplate)) as InGameTimerTemplate);
```

### Property: <mark style="color:yellow;">`TimerType`</mark>

**Getting Timer Type**

To get the type of timer:

```csharp
TimerType timerType = template.TimerType;
```

### Property: <mark style="color:yellow;">`CurrentTime`</mark>

**Getting Current Time**

To get the current time from the in-game timer handler:

```csharp
float currentTime = template.CurrentTime;
```

### Property: <mark style="color:yellow;">`IsUIShown`</mark>

**Checking if UI is Shown**

To check if the UI associated with the timer is currently shown:

```csharp
bool isUIShown = template.IsUIShown;
```

### Event: <mark style="color:yellow;">`OnTimerUpdated`</mark>

**Subscribing to OnTimerUpdated Event**

To subscribe to the event triggered when the timer is updated:

```csharp
template.OnTimerUpdated += OnTimerUpdatedHandler;
```

**Unsubscribing from OnTimerUpdated Event**

To unsubscribe from the event triggered when the timer is updated:

```csharp
template.OnTimerUpdated -= OnTimerUpdatedHandler;
void OnTimerUpdatedHandler(float updatedTime){
   // Handle timer updated event
}
```

## JumpPadTemplate

This template manages jump pad functionality within the game. To access the JumpPadTemplate, use the following code:

```csharp
JumpPadTemplate template = (GetTemplate(typeof(JumpPadTemplate)) as JumpPadTemplate);
```

### Property: <mark style="color:yellow;">`JumpForce`</mark>

**Getting and Setting Jump Force**

To get or set the jump force of the jump pad:

```csharp
float jumpForce = template.JumpForce;
template.JumpForce = 10.0f; // Example of setting jump force
```

## KillPlayerTemplate

This template manages the behavior related to killing the player in the game. To access the KillPlayerTemplate, use the following code:

```csharp
KillPlayerTemplate template = (GetTemplate(typeof(KillPlayerTemplate)) as KillPlayerTemplate);
```

### Property: <mark style="color:yellow;">`AnimationToPlayOnDeath`</mark>

**Getting and Setting Animation to Play on Death**

To get or set the animation to play when the player dies:

```csharp
string animation = template.AnimationToPlayOnDeath;
template.AnimationToPlayOnDeath = "death_animation"; // Example of setting death animation
```

### Property: <mark style="color:yellow;">`Delay`</mark>&#x20;

**Getting and Setting Delay**

To get or set the delay before respawning the player:

```csharp
float delay = template.Delay;
template.Delay = 3.0f; // Example of setting respawn delay
```

### Property: <mark style="color:yellow;">`RespawnType`</mark>&#x20;

**Getting and Setting Respawn Type**

To get or set the respawn type (snap or lerp):

```csharp
RespawnV2.RespwanType respawnType = template.RespawnType;
template.RespawnType = RespawnV2.RespwanType.Lerp; // Example of setting respawn type
```

### Property: <mark style="color:yellow;">`LerpTime`</mark>

**Getting and Setting Lerp Time**

To get or set the lerp time for respawn:

```csharp
float lerpTime = template.LerpTime;
template.LerpTime = 2.0f; // Example of setting lerp time
```

### Events - <mark style="color:yellow;">`OnAnimationEnded`</mark> and <mark style="color:yellow;">`OnRespawned`</mark>

**Subscribing to Events**

You can subscribe to events that occur when animations end or when the player respawns:

```csharp
template.OnAnimationEnded += HandleAnimationEnd;
template.OnRespawned += HandlePlayerRespawn;

void HandleAnimationEnd()
{
    // Handle animation end logic here
}

void HandlePlayerRespawn()
{
    // Handle player respawn logic here
}
```

## LightTemplate

This template manages the behavior related to controlling a light component in the game. To access the LightTemplate, use the following code:

```csharp
LightTemplate template = (GetTemplate(typeof(LightTemplate)) as LightTemplate);
```

### Property: <mark style="color:yellow;">`Color`</mark>

**Getting and Setting Light Color**

To get or set the color of the light:

```csharp
Color color = template.Color;
template.Color = Color.red; // Example of setting light color
```

### Property: <mark style="color:yellow;">`Intensity`</mark>

**Getting and Setting Light Intensity**

To get or set the intensity of the light:

```csharp
float intensity = template.Intensity;
template.Intensity = 2.0; // Example of setting light intensity
```

### Event: <mark style="color:yellow;">`OnLightPropertiesModified`</mark>

**Subscribing to Events**

You can subscribe to an event that occurs when the light properties are modified:

```csharp
template.OnLightPropertiesModified += HandleLightPropertiesModified;

void HandleLightPropertiesModified()
{
    // Handle light properties modified logic here
}
```

## MoveBetweenPointsTemplate

This template facilitates movement between specified points in the game, utilizing interpolation techniques for smooth transitions. To integrate the `MoveBetweenPointsTemplate`, follow the usage instructions below:

```csharp
MoveBetweenPointsTemplate template = (GetTemplate(typeof(MoveBetweenPointsTemplate)) as MoveBetweenPointsTemplate);
```

### Property: <mark style="color:yellow;">`Points`</mark>

**Accessing Movement Points**

To access or modify the points defining the movement path:

```csharp
List<Vector3> points = template.Points;
template.Points = new List<Vector3> { /* Define new points here */ };
```

### Property: <mark style="color:yellow;">`Speed`</mark>

**Controlling Movement Speed**

To adjust the speed of movement between points:

```csharp
float speed = template.Speed;
template.Speed = 5.0f; // Example of setting movement speed
```

### Property:  <mark style="color:yellow;">`TurnToPoints`</mark>

**Aligning to Movement Points**

To enable or disable the rotation towards movement points:

```csharp
bool turnToPoints = template.TurnToPoints;
template.TurnToPoints = true; // Example of enabling rotation towards points
```

### Property: <mark style="color:yellow;">`DelayAtPoint`</mark>

**Introducing Delay at Points**

To specify a delay upon reaching each movement point:

```csharp
float delay = template.DelayAtPoint;
template.DelayAtPoint = 1.5f; // Example of setting delay at points
```

### Property: <mark style="color:yellow;">`Loop`</mark>

**Enabling Movement Loop**

To enable or disable looping of the movement path:

```csharp
bool loop = template.Loop;
template.Loop = true; // Example of enabling movement loop
```

### Property: <mark style="color:yellow;">`DoCurve`</mark>

**Applying Curve to Movement**

To activate or deactivate curve interpolation for movement:

```csharp
bool doCurve = template.DoCurve;
template.DoCurve = true; // Example of enabling curve interpolation
```

### Property: <mark style="color:yellow;">`LoopType`</mark>

**Defining Loop Interpolation Type**

To specify the interpolation type used for movement looping:

```csharp
InterpolateType loopType = template.LoopType;
template.LoopType = InterpolateType.Linear; // Example of setting loop interpolation type
```

### Events

**Subscribing to Movement Events**

You can subscribe to events triggered during movement:

```csharp
template.OnIntervalReached += HandleIntervalReached;
template.OnReachedEnd += HandleMovementEnd;
template.OnLoopFinished += HandleLoopFinished;

void HandleIntervalReached()
{
    // Handle interval reached logic here
}

void HandleMovementEnd()
{
    // Handle movement end logic here
}

void HandleLoopFinished()
{
    // Handle loop finished logic here
}
```



## MoveTemplate

This template facilitates movement functionality within the game, focusing on translating entities using specified parameters. To integrate the `MoveTemplate`, follow the usage instructions below:

```csharp
MoveTemplate template = (GetTemplate(typeof(MoveTemplate)) as MoveTemplate);
```

### Speed Property

**Controlling Movement Speed**

To adjust the speed of movement:

```csharp
float speed = template.Speed;
template.Speed = 5.0f; // Example of setting movement speed
```

### Loop Property

**Enabling Looping Movement**

To enable or disable looping of the movement:

```csharp
bool loop = template.Loop;
template.Loop = true; // Example of enabling looping movement
```

### Interval Property

**Setting Pause Interval**

To specify a pause interval during movement:

```csharp
float interval = template.Interval;
template.Interval = 1.5f; // Example of setting pause interval
```

### Point Property

**Defining Movement Target**

To set the target position for movement:

```csharp
Vector3 point = template.Point;
template.Point = new Vector3(10f, 0f, 5f); // Example of setting movement target position
```

### Events

**Subscribing to Movement Events**

You can subscribe to events triggered during movement:

```csharp
template.OnStopped += HandleStopped;
template.OnResumed += HandleResumed;

void HandleStopped()
{
    // Handle stopped logic here
}

void HandleResumed()
{
    // Handle resumed logic here
}
```



## MoveToPlayerTemplate

This template facilitates movement towards a player entity within the game, utilizing specified parameters. To integrate the `MoveToPlayerTemplate`, follow the usage instructions below:

```csharp
MoveToPlayerTemplate template = (GetTemplate(typeof(MoveToPlayerTemplate)) as MoveToPlayerTemplate);
```

### Speed Property

**Controlling Movement Speed**

To adjust the speed of movement towards the player:

```csharp
float speed = template.Speed;
template.Speed = 7.0f; // Example of setting movement speed towards the player
```

### Offset Property

**Setting Movement Offset**

To specify an offset relative to the player position:

```csharp
Vector3 offset = template.Offset;
template.Offset = new Vector3(0f, 1f, 0f); // Example of setting movement offset
```

### CancelType Property

**Defining Movement Cancellation Type**

To set the type of cancellation for movement:

```csharp
MoveToPlayer.CancelType cancelType = template.CancelType;
template.CancelType = MoveToPlayer.CancelType.Immediate; // Example of setting cancellation type
```

### Events

**Subscribing to Movement Events**

You can subscribe to events triggered during movement towards the player:

```csharp
template.OnCancelled += HandleCancelled;
template.OnReachedDestination += HandleReachedDestination;
template.OnReachedInitialPosition += HandleReachedInitialPosition;

void HandleCancelled()
{
    // Handle cancellation logic here
}

void HandleReachedDestination()
{
    // Handle logic when reaching the player destination here
}

void HandleReachedInitialPosition()
{
    // Handle logic when reaching initial position here
}
```

## ParticleEffectTemplate

This template manages particle effects within the game, offering flexibility in configuration and event handling. Follow the usage guidelines below to integrate the `ParticleEffectTemplate` into your project:

```csharp
ParticleEffectTemplate template = (GetTemplate(typeof(ParticleEffectTemplate)) as ParticleEffectTemplate);
```

### RepeatCount Property

**Adjusting Repeat Count**

To control the number of times the particle effect repeats:

```csharp
int repeatCount = template.RepeatCount;
template.RepeatCount = 3; // Example of setting repeat count
```

### PlayForever Property

**Enabling Continuous Play**

To enable continuous playback of the particle effect:

```csharp
bool playForever = template.PlayForever; // Get whether continuous playback is enabledk
template.PlayForever = true; // Example of enabling continuous playback
```

### Duration Property

**Setting Duration**

To specify the duration of the particle effect:

```csharp
float duration = template.Duration; // Get the duration of the particle effect
template.Duration = 5.0f; // Example of setting duration
```

### Delay Property

**Configuring Delay**

To set the delay between repetitions of the particle effect:

```csharp
int delay = template.Delay; // Get the value of delay set
template.Delay = 2; // Example of setting delay
```

### Events

**Subscribing to Event Notifications**

You can subscribe to events triggered during the lifecycle of the particle effect:

```csharp
template.OnParticlePlayingCompleted += HandleParticlePlayingCompleted;

void HandleParticlePlayingCompleted()
{
    // Handle logic when particle effect playback completes here
}
```

```csharp
```

## PlayAnimationTemplate

This template facilitates the management and execution of animations within the game environment, offering seamless integration and customization options. Follow the guidelines below to effectively utilize the `PlayAnimationTemplate` class in your project:

```csharp
PlayAnimationTemplate template = (GetTemplate(typeof(PlayAnimationTemplate)) as PlayAnimationTemplate);
```

### CurrentAnimation Property

**Retrieving Current Animation**

To fetch the currently playing animation:

```csharp
string currentAnimation = template.CurrentAnimation;
```

### DefaultAnimation Property

**Setting Default Animation**

To set the default animation for the component:

```csharp
string defaultAnimation = template.DefaultAnimation;
template.DefaultAnimation = "Idle"; // Example of setting default animation
```

### AvailableAnimations Property

**Accessing Available Animations**

To retrieve a list of available animations:

```csharp
TerraList availableAnimations = template.AvailableAnimations;
```

### Events

**Handling Animation Events**

You can subscribe to animation completion events:

```csharp
template.OnAnimationCompleted += HandleAnimationCompleted;

void HandleAnimationCompleted(string animationName)
{
    // Handle logic when animation completes here
}
```

### Methods

**Controlling Animation Playback**

You can control animation playback using the following methods:

```csharp
template.PlayAnimationOverride("Run", true); // Example of playing an animation with looping
template.StopAnimationOverride(); // Example of stopping the current animation
```



## PlayerAnimationControlTemplate

The `PlayerAnimationControlTemplate` class facilitates the control and management of player animations within the game environment, offering seamless integration and customization options. Follow the guidelines below to effectively utilize this template in your project:

```csharp
PlayerAnimationControlTemplate template = (GetTemplate(typeof(PlayerAnimationControlTemplate)) as PlayerAnimationControlTemplate);
```

### AnimationName Property

**Setting and Retrieving Animation Name**

To get or set the current animation name:

```csharp
string animationName = template.AnimationName;
template.AnimationName = "Run"; // Example of setting animation name
```

### ResetAnimationAutomatically Property

**Enabling or Disabling Automatic Animation Reset**

To enable or disable automatic animation reset:

```csharp
bool resetAutomatically = template.ResetAnimationAutomatically;
template.ResetAnimationAutomatically = true; // Example of enabling automatic reset
```

### Events

**Handling Animation Completion Events**

You can subscribe to animation completion events:

```csharp
template.OnAnimationCompleted += HandleAnimationCompleted;

void HandleAnimationCompleted(bool success, string animationName)
{
    // Handle logic when animation completes here
}
```



## PlayPlayersAnimationTemplate

The `PlayPlayersAnimationTemplate` class is designed to manage and control player animations within your game environment, providing essential properties for seamless integration and customization. Here's how you can utilize this template effectively in your project:

```csharp
PlayPlayersAnimationTemplate template = (GetTemplate(typeof(PlayPlayersAnimationTemplate)) as PlayPlayersAnimationTemplate);
```

### AnimationName Property

**Setting and Retrieving Animation Name**

To get or set the current animation name:

```csharp
string animationName = template.AnimationName;
template.AnimationName = "Jump"; // Example of setting animation name
```

### ResetAnimationAutomatically Property

**Enabling or Disabling Automatic Animation Reset**

To enable or disable automatic animation reset:

```csharp
bool resetAutomatically = template.ResetAnimationAutomatically;
template.ResetAnimationAutomatically = true; // Example of enabling automatic rese
```

## PushTemplate

The `PushTemplate` class facilitates control over push components within your game, offering methods to manage resistance properties effectively. Below is a detailed overview of its usage:

```csharp
PushTemplate template = (GetTemplate(typeof(PushTemplate)) as PushTemplate);
```

### Resistance Property

**Managing Resistance**

To access or modify the resistance of the push component:

```csharp
float resistance = template.Resistance;
template.Resistance = 2.5f; // Example of setting resistance value
```

## RandomBroadcastTemplate

This template manages random broadcasting functionality within the game, utilizing specified parameters to handle broadcast strings. To integrate the `RandomBroadcastTemplate`, follow the usage instructions below:

```csharp
RandomBroadcastTemplate template = (GetTemplate(typeof(RandomBroadcastTemplate)) as RandomBroadcastTemplate);
```

### GetAllBroadcastingStrings Property

Fetching All Broadcasting Strings

To retrieve all broadcasting strings:

```csharp
List<string> broadcastingStrings = template.GetAllBroadcastingStrings;
```

### Indexer

Accessing Specific Broadcasting String by Index

To access or modify a specific broadcasting string:

```csharp
string broadcast = template[index];
template[index] = "New Broadcast"; // Example of updating a broadcasting string
```

### GetEnumerator Method

Enumerating Through Broadcasting Strings

To iterate through all broadcasting strings:

```csharp
IEnumerator enumerator = template.GetEnumerator();
while (enumerator.MoveNext())
{
    string broadcast = (string)enumerator.Current;
    // Process each broadcast here
}
```

### CheckIndex Method

Validating Index for Broadcasting Strings

To validate an index before accessing or modifying broadcasting strings:

```csharp
try
{
    template.CheckIndex(index);
    // Proceed with index-valid operations
}
catch (ArgumentOutOfRangeException ex)
{
    // Handle index out of range exception
}
```

### UpdateConditionBroadcasts Method

Updating Broadcasting Strings

To update a specific broadcasting string:

```csharp
template.UpdateConditionBroadcasts(index, "Updated Broadcast")
```

## ResetScoreTemplate

This template manages the resetting of scores within the game, utilizing specified parameters to handle score groups. To integrate the `ResetScoreTemplate`, follow the usage instructions below:

```csharp
ResetScoreTemplate template = (GetTemplate(typeof(ResetScoreTemplate)) as ResetScoreTemplate);
```

### ScoreGroup Property

Managing Score Group

To get or set the score group:

```csharp
string scoreGroup = template.ScoreGroup;
template.ScoreGroup = "NewScoreGroup"; // Example of updating the score group
```

## RotateOscillateTemplate

This template manages the rotation oscillation behavior within the game, allowing customization of the rotation parameters such as axis, degrees, direction, repeat count, and event triggers. To integrate the `RotateOscillateTemplate`, follow the usage instructions below:

```csharp
RotateOscillateTemplate template = (GetTemplate(typeof(RotateOscillateTemplate)) as RotateOscillateTemplate);
```

### RotationAxis Property

Managing Rotation Axis

To get or set the rotation axis:

```csharp
Axis rotationAxis = template.RotationAxis;
template.RotationAxis = Axis.Y; // Example of updating the rotation axis
```

### Degrees Property

Managing Rotation Degrees

To get or set the degrees of rotation:

```csharp
int degrees = template.Degrees;
template.Degrees = 90; // Example of updating the degrees
```

### Direction Property

Managing Rotation Direction

To get or set the rotation direction:

```csharp
Direction direction = template.Direction;
template.Direction = Direction.Clockwise; // Example of updating the direction
```

### RepeatCount Property

Managing Repeat Count

To get or set the repeat count for the rotation:

```csharp
int repeatCount = template.RepeatCount;
template.RepeatCount = 5; // Example of updating the repeat count
```

### Loop Property

Checking Loop Status

To check if the rotation is looping:

```csharp
bool isLooping = template.Loop;
```

### StopOn Property

Managing Stop Condition

To get or set the condition to stop the rotation:

```csharp
string stopOn = template.StopOn;
template.StopOn = "SomeCondition"; // Example of updating the stop condition
```

### ResumeOn Property

Managing Resume Condition

To get or set the condition to resume the rotation:

```csharp
string resumeOn = template.ResumeOn;
template.ResumeOn = "SomeOtherCondition"; // Example of updating the resume condition
```

### Events

Handling Rotation Events

#### OnRepetitionCompleted Event

To subscribe or unsubscribe from the repetition completed event:

```csharp
csharpCopy codetemplate.OnRepetationCompleted += YourEventHandler;
template.OnRepetationCompleted -= YourEventHandler;
```

#### OnRotationCompleted Event

To subscribe or unsubscribe from the rotation completed event:

```csharp
template.OnRotationCompleted += YourEventHandler;
template.OnRotationCompleted -= YourEventHandler;
```

#### OnRotationPaused Event

To subscribe or unsubscribe from the rotation paused event:

```csharp
template.OnRotationPaused += YourEventHandler;
template.OnRotationPaused -= YourEventHandler;
```

#### OnRotationResumed Event

To subscribe or unsubscribe from the rotation resumed event:

```csharp
template.OnRotationResumed += YourEventHandler;
template.OnRotationResumed -= YourEventHandler;
```

## RotateTemplate

This template manages the rotation behavior within the game, allowing customization of the rotation parameters such as axis, speed, and direction. To integrate the `RotateTemplate`, follow the usage instructions below:

```csharp
RotateTemplate template = (GetTemplate(typeof(RotateTemplate)) as RotateTemplate);
```

### RotationAxis Property

Managing Rotation Axis

To get or set the rotation axis:

```csharp
Axis rotationAxis = template.RotationAxis;
template.RotationAxis = Axis.Y; // Example of updating the rotation axis
```

### Speed Property

Managing Rotation Speed

To get or set the speed of rotation:

```csharp
float speed = template.Speed;
template.Speed = 5.0f; // Example of updating the speed
```

### Direction Property

Managing Rotation Direction

To get or set the rotation direction:

```csharp
Direction direction = template.Direction;
template.Direction = Direction.Clockwise; // Example of updating the direction
```

## SetPositionTemplate

This template is used to set the position of an object within the game engine and can be accessed as follows:

```csharp
SetPositionTemplate positionTemplate = GetTemplate(typeof(SetPositionTemplate)) as SetPositionTemplate;
```

### TargetPosition

You can access or set the target position for the object using the `TargetPosition` property.

```scss
positionTemplate.TargetPosition = new Vector3(10, 20, 30); // Sets the target position to (10, 20, 30)
```

### OnPositionUpdated

You can subscribe to the `OnPositionUpdated` event to execute custom logic whenever the position is updated.

```csharp
positionTemplate.OnPositionUpdated += () =>
{
    // Custom logic to execute when the position is updated
    Debug.Log("Position updated");
};
```



## ShowUITemplate

This template manages the display of UI elements within the game, allowing customization of the UI animation type, screen position, icons, texts, and durations. To integrate the `ShowUITemplate`, follow the usage instructions below:

```csharp
ShowUITemplate template = (GetTemplate(typeof(ShowUITemplate)) as ShowUITemplate);
```

### AnimationType Property

Managing UI Animation Type

To get or set the UI animation type:

```csharp
UIAnimation animationType = template.AnimationType;
template.AnimationType = UIAnimation.FadeIn; // Example of updating the animation type
```

### ScreenPosition Property

Managing Screen Position

To get or set the screen position:

```csharp
UIPoint screenPosition = template.ScreenPosition;
template.ScreenPosition = new UIPoint(100, 200); // Example of updating the screen position
```

### UIToShow Property

Managing the UI to Show

To get or set the UI element to show:

```csharp
string uiToShow = template.UIToShow;
template.UIToShow = "MainMenu"; // Example of updating the UI element to show
```

### Icon1Name Property

Managing the First Icon Name

To get or set the name of the first icon:

```csharp
string icon1Name = template.Icon1Name;
template.Icon1Name = "Icon1"; // Example of updating the first icon name
```

### Icon2Name Property

Managing the Second Icon Name

To get or set the name of the second icon:

```csharp
string icon2Name = template.Icon2Name;
template.Icon2Name = "Icon2"; // Example of updating the second icon name
```

### Text1 Property

Managing the First Text

To get or set the first text:

```csharp
string text1 = template.Text1;
template.Text1 = "Welcome"; // Example of updating the first text
```

### Text2 Property

Managing the Second Text

To get or set the second text:

```csharp
string text2 = template.Text2;
template.Text2 = "Start Game"; // Example of updating the second text
```

### Text3 Property

Managing the Third Text

To get or set the third text:

```csharp
string text3 = template.Text3;
template.Text3 = "Options"; // Example of updating the third text
```

### AnimationDuration Property

Managing Animation Duration

To get or set the animation duration:

```csharp
float animationDuration = template.AnimationDuration;
template.AnimationDuration = 1.5f; // Example of updating the animation duration
```

### UIDuration Property

Managing UI Display Duration

To get or set the duration for which the UI is displayed:

```csharp
float uiDuration = template.UIDuration;
template.UIDuration = 5.0f; // Example of updating the UI display duration
```



## SoundFxTemplate

This template manages the sound effects within the game, allowing customization of volume, pitch, 3D audio settings, distance ranges, looping capabilities, and pause/resume events. To integrate the `SoundFxTemplate`, follow the usage instructions below:

```csharp
SoundFxTemplate template = (GetTemplate(typeof(SoundFxTemplate)) as SoundFxTemplate);
```

### Volume Property

Managing Volume

To get or set the volume:

```csharp
float volume = template.Volume;
template.Volume = 0.5f; // Example of updating the volume
```

### Pitch Property

Managing Pitch

To get or set the pitch:

```csharp
float pitch = template.Pitch;
template.Pitch = 1.0f; // Example of updating the pitch
```

### Is3DAudio Property

Managing 3D Audio

To get or set whether the sound is 3D audio:

```csharp
bool is3DAudio = template.Is3DAudio;
template.Is3DAudio = true; // Example of enabling 3D audio
```

### MinDistance Property

Managing Minimum Distance

To get or set the minimum distance for 3D audio:

```csharp
float minDistance = template.MinDistance;
template.MinDistance = 1.0f; // Example of updating the minimum distance
```

### MaxDistance Property

Managing Maximum Distance

To get or set the maximum distance for 3D audio:

```csharp
float maxDistance = template.MaxDistance;
template.MaxDistance = 50.0f; // Example of updating the maximum distance
```

### CanLoop Property

Managing Looping

To get or set whether the sound can loop:

```csharp
bool canLoop = template.CanLoop;
template.CanLoop = true; // Example of enabling looping
```

### PauseOn Property

Managing Pause Event

To get or set the event on which the sound pauses:

```csharp
string pauseOn = template.PauseOn;
template.PauseOn = "PlayerDeath"; // Example of updating the pause event
```

### ResumeOn Property

Managing Resume Event

To get or set the event on which the sound resumes:

```csharp
string resumeOn = template.ResumeOn;
template.ResumeOn = "PlayerRespawn"; // Example of updating the resume event
```

### OnPaused Event

Managing OnPaused Event

To add or remove a callback for when the sound is paused:

```csharp
template.OnPaused += OnSoundPaused; // Adding a callback
template.OnPaused -= OnSoundPaused; // Removing a callback

void OnSoundPaused()
{
    // Your code here
}
```

### OnResumed Event

Managing OnResumed Event

To add or remove a callback for when the sound is resumed:

```csharp
template.OnResumed += OnSoundResumed; // Adding a callback
template.OnResumed -= OnSoundResumed; // Removing a callback

void OnSoundResumed()
{
    // Your code here
}
```



## SwitchTemplate

This template manages the switch component within the game, allowing the addition of custom actions when the switch is toggled on or off. To integrate the `SwitchTemplate`, follow the usage instructions below:

```csharp
SwitchTemplate template = (GetTemplate(typeof(SwitchTemplate)) as SwitchTemplate);
```

### OnToggledOn Event

Managing OnToggledOn Event

To add or remove a callback for when the switch is toggled on:

```csharp
template.OnToggledOn += OnSwitchToggledOn; // Adding a callback
template.OnToggledOn -= OnSwitchToggledOn; // Removing a callback

void OnSwitchToggledOn()
{
    // Your code here
}
```

### OnToggledOff Event

Managing OnToggledOff Event

To add or remove a callback for when the switch is toggled off:

```csharp
template.OnToggledOff += OnSwitchToggledOff; // Adding a callback
template.OnToggledOff -= OnSwitchToggledOff; // Removing a callback

void OnSwitchToggledOff()
{
    // Your code here
}
```

## TeleportTemplate

This template manages the teleport component within the game, allowing the addition of custom actions when teleportation occurs. To integrate the `TeleportTemplate`, follow the usage instructions below:

```csharp
TeleportTemplate template = (GetTemplate(typeof(TeleportTemplate)) as TeleportTemplate);
```

### TeleportPoint Property

Getting and Setting the TeleportPoint

To get or set the teleport destination point:

```csharp
Vector3 currentPoint = template.TeleportPoint; // Getting the teleport point
template.TeleportPoint = new Vector3(x, y, z); // Setting the teleport point
```

### OnTeleported Event

Managing OnTeleported Event

To add or remove a callback for when the teleportation occurs:

```csharp
template.OnTeleported += OnTeleport; // Adding a callback
template.OnTeleported -= OnTeleport; // Removing a callback

void OnTeleport()
{
    // Your code here
}
```



## TickTemplate

This template manages the tick component within the game, providing access to conditions and events related to tick operations. To integrate the `TickTemplate`, follow the usage instructions below:

```csharp
TickTemplate template = (GetTemplate(typeof(TickTemplate)) as TickTemplate);
```

### Indexer

Getting and Setting Values by Index

To get or set values by index:

```csharp
string value = template[index]; // Getting value by index
template[index] = "newValue"; // Setting value by index
```

### Length Property

Getting the Length of Condition Broadcasts

To get the number of condition broadcasts:

```csharp
int length = template.Length;
```

### StartOn Property

Getting and Setting the Start Condition

To get or set the start condition:

```csharp
string startCondition = template.StartOn; // Getting the start condition
template.StartOn = "newStartCondition"; // Setting the start condition
```

### StopOn Property

Getting and Setting the Stop Condition

To get or set the stop condition:

```csharp
string stopCondition = template.StopOn; // Getting the stop condition
template.StopOn = "newStopCondition"; // Setting the stop condition
```

### ResumeOn Property

Getting and Setting the Resume Condition

To get or set the resume condition:

```csharp
string resumeCondition = template.ResumeOn; // Getting the resume condition
template.ResumeOn = "newResumeCondition"; // Setting the resume condition
```

### OnStarted Event

Managing OnStarted Event

To add or remove a callback for when the tick starts:

```csharp
template.OnStarted += OnTickStarted; // Adding a callback
template.OnStarted -= OnTickStarted; // Removing a callback

void OnTickStarted()
{
    // Your code here
}
```

### OnPaused Event

Managing OnPaused Event

To add or remove a callback for when the tick is paused:

```csharp
template.OnPaused += OnTickPaused; // Adding a callback
template.OnPaused -= OnTickPaused; // Removing a callback

void OnTickPaused()
{
    // Your code here
}
```

### OnResumed Event

Managing OnResumed Event

To add or remove a callback for when the tick is resumed:

```csharp
template.OnResumed += OnTickResumed; // Adding a callback
template.OnResumed -= OnTickResumed; // Removing a callback

void OnTickResumed()
{
    // Your code here
}
```

### OnTick Event

Managing OnTick Event

To add or remove a callback for each tick:

```csharp
template.OnTick += OnTickAction; // Adding a callback
template.OnTick -= OnTickAction; // Removing a callback

void OnTickAction()
{
    // Your code here
}
```

## TogglePlayerMovementTemplate

## TogglePlayerMovementTemplate

This template manages the player movement component, specifically handling the stun animation and shader effects, and provides events for pause and resume actions. To integrate the `TogglePlayerMovementTemplate`, follow the usage instructions below:

```csharp
TogglePlayerMovementTemplate template = (GetTemplate(typeof(TogglePlayerMovementTemplate)) as TogglePlayerMovementTemplate);
```

### PlayStunAnimation Property

Getting and Setting the Stun Animation

To get or set the stun animation state:

```csharp
bool isStunAnimationOn = template.PlayStunAnimation; // Getting the stun animation state
template.PlayStunAnimation = true; // Setting the stun animation state
```

### ChangeToStunShader Property

Getting and Setting the Stun Shader

To get or set the stun shader state:

```csharp
bool isStunShaderOn = template.ChangeToStunShader; // Getting the stun shader state
template.ChangeToStunShader = true; // Setting the stun shader state
```

### ResumeOn Property

Getting and Setting the Resume Condition

To get or set the resume condition:

```csharp
string resumeCondition = template.ResumeOn; // Getting the resume condition
template.ResumeOn = "newResumeCondition"; // Setting the resume condition
```

### OnPaused Event

Managing OnPaused Event

To add or remove a callback for when the player movement is paused:

```csharp
template.OnPaused += OnMovementPaused; // Adding a callback
template.OnPaused -= OnMovementPaused; // Removing a callback

void OnMovementPaused()
{
    // Your code here
}
```

### OnResumed Event

Managing OnResumed Event

To add or remove a callback for when the player movement is resumed:

```csharp
template.OnResumed += OnMovementResumed; // Adding a callback
template.OnResumed -= OnMovementResumed; // Removing a callback

void OnMovementResumed()
{
    // Your code here
}
```

## UpdateScoreTemplate

This template manages the update score component, specifically handling score groups, modifiers, and score values. It integrates with the `ScoreHandler` to get and set scores. To integrate the `UpdateScoreTemplate`, follow the usage instructions below:

```csharp
UpdateScoreTemplate template = (GetTemplate(typeof(UpdateScoreTemplate)) as UpdateScoreTemplate);
```

### ScoreGroup Property

Getting and Setting the Score Group

To get or set the score group:

```csharp
string scoreGroup = template.ScoreGroup; // Getting the score group
template.ScoreGroup = "newScoreGroup"; // Setting the score group
```

### Modifier Property

Getting and Setting the Modifier

To get or set the modifier:

```csharp
Modifier modifier = template.Modifier; // Getting the modifier
template.Modifier = Modifier.Add; // Setting the modifier
```

### Score Property

Getting and Setting the Score

To get or set the score:

```csharp
int score = template.Score; // Getting the score
template.Score = 100; // Setting the score
```

### GetScore Method

Retrieving the Current Score

To get the current score from the `ScoreHandler`:

```csharp
int currentScore = template.GetScore();
```

### SetScore Method

Setting a New Score

To set a new score using the `ScoreHandler`:

```csharp
template.SetScore(150);
```

## UpdateTimerTemplate

This template manages the update timer component, specifically handling modifiers, update intervals, and current time. It integrates with the `InGameTimeHandler` to get and set in-game time. To integrate the `UpdateTimerTemplate`, follow the usage instructions below:

```csharp
UpdateTimerTemplate template = (GetTemplate(typeof(UpdateTimerTemplate)) as UpdateTimerTemplate);
```

### Modifier Property

Getting and Setting the Modifier

To get or set the modifier:

```csharp
Modifier modifier = template.Modifier; // Getting the modifier
template.Modifier = Modifier.Add; // Setting the modifier
```

### UpdateBy Property

Getting and Setting the Update Interval

To get or set the update interval:

```csharp
int updateBy = template.UpdateBy; // Getting the update interval
template.UpdateBy = 5; // Setting the update interval
```

### CurrentTime Property

Getting and Setting the Current Time

To get or set the current time:

```csharp
float currentTime = template.CurrentTime; // Getting the current time
template.CurrentTime = 10.5f; // Setting the current time
```

### GetTime Method

Retrieving the Current Time

To get the current time from the `InGameTimeHandler`:

```csharp
float currentTime = template.GetTime();
```

### SetTime Method

Setting a New Time

To set a new time using the `InGameTimeHandler`:

```csharp
template.SetTime(12.0f);
```

# T# Basics

## About T\#

Earlier, creators ability to make a variety of games was limited by the number of logic templates that were available in its logic template library.&#x20;

To remove this limitation , we introduce a new scripting language -  - which has a syntax almost similar to C#. This was developed to provide developers who are used to writing code the flexibility to do almost anything on Terra's platforms.&#x20;

A knowledge of Unity C# makes it super easy for you learn T#, but you need to take care of certain things that are different in T#. Read the [T# Don'ts](t-donts.md) to be aware of these.

T# removes this constraint. Now even if you don't have a logic template in Terra Studio, you can go ahead and write your own script to make that happen.

## Creating your own Script

You can create your own T# scripts to customize game behavior. Here's how:

1. Click the Scripts Tab in the left panel.
2. To add a new script:
   1. Click the `+` icon.
   2. Enter a name and press Enter.&#x20;
3. Double-click the file to open it. Your script will compile and be ready.
4. The Visual Studio Code IDE will open all the scripts in the project.&#x20;
5. Locate your script in the Scripts Directory.&#x20;
6. You can now edit the default code to achieve your  desired behavior

## Adding your Script to an Asset

Scripts define how assets behave during gameplay. To enable this, attach a script to an asset. Here's how you can do it:

1. Select the asset to add the script
2. Go to the Logic Tab on the left
3. Drag and drop the Studio Machine Behavior onto the asset.
4. Enable Advanced Mode. The Inspector Panel appears on the right.
5. Go to the Studio Machine Tab in the Inspector Panel and open the dropdown to see all scripts in the project.&#x20;
6. Choose the script you want to add.

## Basic Structure of a default T# Script

When you open a script in Visual Studio Code, a default script like this appears:

<pre class="language-csharp"><code class="lang-csharp">
using System;
using System.Collections;
using Terra.Studio;
using Terra.Studio.Exposed;
using Terra.Studio.Exposed.Layers;
using UnityEngine;

public class MyFirstScript : StudioBehaviour
{
    private void Start()
    {
       
    }

    private void Update()
    {
       
    }

    public override void OnBroadcasted(string x)
    {
        
    }
}

<strong>
</strong></code></pre>

Note an important difference:&#x20;

Terra Studio uses `StudioBehavior` and not `MonoBehavior`&#x20;

```csharp
public class MyFirstScript : StudioBehaviour
{
 // Enter functions here
 }
```

instead of&#x20;

```csharp
/*MonoBehavior is not used in Terra Studio but instead used only in Unity*/
public class MyFirstScript : MonoBehaviour
{
 // Enter functions here
 }

```

###

### `Start()`

This function gets called at the start of the game object's lifecycle and can be used to perform actions at the start of a game

```csharp
private void Start()
    {
      // Enter code to dictate what happens at the start of the game
       
    }
```

### `Update()`

This runs on every frame and can be used to dynamically update interactions

```csharp
private void Update()
    {
       // Enter code to tell what should happen on each frame
    }
```



### `OnBroadcasted()`

This runs whenever a broadcasted signal is listened to by the object

```csharp
// There is an object in the scene that generates the custom broadcast  "signal" is 
public override void OnBroadcasted(string x)
    {
    // The code below executes doSomething when it listens to the broadcast x
        if(String.Equals(x,"signal")){
        doSomething();
        }
        
    }
```



## Adding Custom Variables to an Asset

Add custom local variables to an asset to use them in your scripts. To add a variable,

1. Select the asset to add the script
2. Go to the Logic Tab on the left
3. Drag and drop the Studio Machine Behavior onto the asset.
4. Enable Advanced Mode. The Inspector Panel appears on the right.
5. Go to the Object Variables tab. There are four types of custom variables you can create:
   1. String
   2. Int
   3. Float
   4. GameObject
6. Click on the + icon next to the variable you want to add. Each variable needs to have a name and a value.

## Accessing Variables in your script

Variables created in an asset can be referenced in all scripts that are added to that asset. Here is how you access the variables:&#x20;

First, declare new variables of the same type to access those created in the editor:

```csharp
private float myVariable1; // A float variable created to access the float variable created in the editor
```

You can access these variables inside any function:

```csharp
 private void Start()
    {
       myVariable1 = GetFloatVariable("a"); // Access the float variable 'a' created in the editor
       // Add code here
    }
```

You can do this for all variable types: &#x20;

```csharp
public class MyFirstScript : StudioBehaviour
{
 
 //Declare new variables to acceess the variables you have created
   private float myVariable1; // To access the float variable
   private string myVariable2; // To access the String Variable
   private int myVariable3; // To access the int variable
   private GameObject myVariable4; // To access the game object variable
    
    private void Start()
    {
       myVariable1 = GetFloatVariable("a"); // Access the float variable 'a' created in the editor
       myVariable2 = GetStringVariable("b"); // Access the string variable 'b'  
       myVariable3 = GetIntVariable("c"); // Access the integer variable 'c'
       myVariable4 = GetGameObjectVariable("d"); // Access the game object variable 'd'
       // Add code here 
    }

    private void Update()
    {
       // Add code here
    }

    public override void OnBroadcasted(string x)
    {
      // Add code here         
    }
}
```



## Generating a Custom Broadcast

You can create your own custom broadcast inside any function

```csharp


public class MyFirstScript : StudioBehaviour
{
    private void Start()
    {
         Broadcast("signal"); // Generates the broadcast "signal"       
    }

    private void Update()
    {
       // Add code
    }

    public override void OnBroadcasted(string x)
    {
       // Add code        
    }
}
```



## Accessing Behavior Templates

Terra has a list of logic templates which you can use readily. However, you can also modify these templates through T# wrappers for each template. To do so:&#x20;

First, access all the wrappers of a specific behavior template by declaring a variable like this:

```csharp
CollectableTemplate collect = (GetTemplate(typeof(CollectableTemplate) as CollectableTemplate);
//the variable 'collect' can now be used to access all the properties of the collect behavior
```

Now use this variable to change all the properties of that behavior:

```csharp
CollectableTemplate collect = (GetTemplate(typeof(CollectableTemplate) as CollectableTemplate);
collect.Score = 10; // Score is a property which can now be modified 
```

A list of T# wrappers that help you access the  variables for each template can be found in [T# Logic Template Wrappers](t-logic-template-wrappers.md).


# T# Haptics & Extensions

## StudioHaptics

This class provides static methods to play different haptic feedback patterns. It uses the Lofelt Nice Vibrations library to trigger haptic feedback on supported devices.

#### Method: **PlayHapticSelection**

Plays the haptic feedback for selection.

```csharp
StudioHaptics.PlayHapticSelection();
```

Method: **PlayHapticSuccess**

Plays the haptic feedback for success.

```csharp
StudioHaptics.PlayHapticSuccess();
```

Method: **PlayHapticWarning**

Plays the haptic feedback for warning.

```csharp
StudioHaptics.PlayHapticWarning();
```

Method: **PlayHapticFailure**

Plays the haptic feedback for failure.

```csharp
StudioHaptics.PlayHapticFailure();
```

Method: **PlayHapticLightImpact**

Plays the haptic feedback for light impact.

```csharp
StudioHaptics.PlayHapticLightImpact();
```

Method: **PlayHapticMediumImpact**

Plays the haptic feedback for medium impact.

```csharp
StudioHaptics.PlayHapticMediumImpact();
```

Method: **PlayHapticHeavyImpact**

Plays the haptic feedback for heavy impact.

```csharp
StudioHaptics.PlayHapticHeavyImpact();
```

Method: **PlayHapticRigidImpact**

Plays the haptic feedback for rigid impact.

```csharp
StudioHaptics.PlayHapticRigidImpact();
```

Method: **PlayHapticSoftImpact**

Plays the haptic feedback for soft impact.

```csharp
StudioHaptics.PlayHapticSoftImpact();
```



## StudioExtensions

This class provides static methods for various utility functions within the Terra Studio environment.

#### Methods: **SetCurrentScore**

Sets the current score for a specified group.

```csharp
StudioExtensions.SetCurrentScore("group1", 100);
```

Methods: **GetCurrentScore**

Gets the current score for a specified group.

```csharp
int score = StudioExtensions.GetCurrentScore("group1");
```

Methods: **DestroyObject**

Destroys the specified GameObject. (Deprecated: Use `StudioBehaviour.Destroy()` instead)

```csharp
StudioExtensions.DestroyObject(gameObject);
```

Methods: **LoadScene**

Loads the specified scene by name.

```csharp
StudioExtensions.LoadScene("SceneName");
```

Methods: **GetAllScenes**

Returns a list of all scenes.

```csharp
TerraList allScenes = StudioExtensions.GetAllScenes();
```

Methods: **GetCurrentScene**

Returns the name of the current scene.

```csharp
string currentScene = StudioExtensions.GetCurrentScene();
```

Methods: **GetColorFromHex**

Converts a hex string to a Color.

```csharp
Color color = StudioExtensions.GetColorFromHex("#FFFFFF");
```

Methods: **FindDeepChild**

Finds a child transform by name, searching recursively.

```csharp
Transform child = StudioExtensions.FindDeepChild(parentTransform, "ChildName");
```

#### Example Usage:

```csharp
csharpCopy codeusing Terra.Studio.Exposed;

// Set the current score for a group
StudioExtensions.SetCurrentScore("group1", 100);

// Get the current score for a group
int score = StudioExtensions.GetCurrentScore("group1");

// Destroy a GameObject (deprecated)
StudioExtensions.DestroyObject(gameObject);

// Load a scene by name
StudioExtensions.LoadScene("SceneName");

// Get all scenes
TerraList allScenes = StudioExtensions.GetAllScenes();

// Get the current scene name
string currentScene = StudioExtensions.GetCurrentScene();

// Convert a hex string to a Color
Color color = StudioExtensions.GetColorFromHex("#FFFFFF");

// Find a child transform by name
Transform child = StudioExtensions.FindDeepChild(parentTransform, "ChildName");
```


# Configuring Game Logic

To make our game interactive, we introduce game logic, which brings the game to life and changes a simple, static game into an engaging world that reacts to what the player does.

There are three ways to add game logic in Terra Studio&#x20;

1. [Writing your own code in T-Sharp](configuring-game-logic.md#writing-your-own-code-in-t)
2. [Using Logic Templates](configuring-game-logic.md#using-logic-templates)
3. [Hybrid Approach - Logic Templates + Coding](configuring-game-logic.md#hybrid-approach-templates--coding)

## Writing your own code in T\#

**Terra Creator Studio** enables experienced game developers to implement custom logic using a scripting language called **T# (T-Sharp)**. T# is very similar to Unity's C#, making it easy for Unity developers to learn. The links below provide detailed guidance on writing T-Sharp code:

[Basics of T-Sharp](../coding-using-t/t-basics.md)

[Differences between T# and C#](../coding-using-t/t-donts.md)&#x20;

## Using Logic Templates

To accelerate the time to create games, Terra Creator Studio also provides pre-built logic blocks or components, known as Templates. These Templates represent various logical operations, conditions, and actions, and can be easily selected from the Editor and dragged and dropped onto Assets.

### What is a Logic Template?

A "Logic Template" is always added to an Asset.  It contains pre-built instructions on how  the Player, Assets and Game Systems should behave.  Here are some important things to remember about templates

1. A Logic Template is always added to an Asset.
2. Execution of a Logic Template is always triggered by a Start Event
3. A Logic Template can affect not only the Asset to which it is attached, but also other Assets, Game Scene Objects and Game Systems&#x20;

{% hint style="info" %}
Logic template should not be added directed to an animated object.
{% endhint %}

### Start Events for Logic Templates

Logic Templates in Terra Studio start executing any of the five events listed below occur:

<table><thead><tr><th width="215">Start Event Name</th><th>Logic Template is executed when</th></tr></thead><tbody><tr><td>Game Start</td><td>The game starts</td></tr><tr><td>Mouse Click</td><td>You click the mouse</td></tr><tr><td>Player Touch / Player Collide</td><td>The Player touches or collides with the Assets collider.</td></tr><tr><td>Other Object Touch</td><td>The other Asset's collider touches the collider of the asset to which the Logic Template is attached</td></tr><tr><td>Broadcast Listened</td><td>A specified game signal is generated in the game. <br><em>E.g - If the Start Event is set to Broadcast Listened - 'level_finish', the logic template will execute only when the game signal 'level_finish' is generated during the game.</em></td></tr></tbody></table>

### Effects of Logic Templates

A logic template when added to an Asset can be set up to not only affect that Asset, but also other Assets, the Player, the Game Scene or even Game Systems.&#x20;

The most common effects of logic templates are :&#x20;

* Change in Player or Asset properties&#x20;
* Change in Game Scene Environment
* Change in Game Systems&#x20;
* Change in an Asset's Orientation&#x20;
* Create or Eliminates existing Game Scene Objects.
* Generate a Custom Broadcast Signal
* Enable an SFX or Particle

The last two effects - generating a broadcast signal and enabling an SFX or VFX is present in every logic template&#x20;

The other effects can be configured in the Editable Properties of each logic template&#x20;

### How to add Logic Templates

To add a logic template to an asset and customise it, follow these steps:

1. Select the Asset in the scene editor or through the Layers Panel.
2. Click the Logic tab in the Quick Access Menu on the left
3. You'll see a Logic Selector with all the possible logic templates&#x20;
4. Choose the logic template you want and drag and drop into the Asset
5. The logic template has been added to the Asset.&#x20;
6. You can configure the logic template's properties by selecting the Advanced Mode toggle button and editing the various accessible fields.
7. Once you make changes, click the Save button in the main toolbar.&#x20;

### How to execute logic templates in parallel

You can execute multiple logic templates on the same Asset in parallel. Each logic template can function independently and gets triggered by its own Start Event. &#x20;

### How to sequentially execute logic templates

&#x20;You can execute logic templates sequentially one after the other by using the Custom Broadcast Start Event.&#x20;

The first logic template can generate a custom broadcast signal upon execution. This broadcast signal can then be the start event of the second logic template

### List of Available Logic Templates

Terra Studio has a wide selection of logic templates for you to choose from. A logic template can be added to any Asset and configured to elicit the interactivity you want in the game. The table below shows a list of logic template and a short description of what they do. A detailed description of each logic template is given in the respective logic template page.&#x20;

#### Overall Gameplay

<table><thead><tr><th width="259">Logic Template</th><th>Description</th></tr></thead><tbody><tr><td><a href="../logic-templates/overall-game/checkpoint.md">Checkpoint</a></td><td>Restarts the game from a specific point if you fail a challenge or lose a life</td></tr><tr><td><a href="../logic-templates/overall-game/update-timer.md">Update Timer</a></td><td>Updates the timer  to a new specified value</td></tr><tr><td><a href="../logic-templates/overall-game/reset-timer.md">Reset Timer</a></td><td>Resets the timer to zero</td></tr><tr><td><a href="../logic-templates/overall-game/load-scene.md">Load Scene</a></td><td>Loads a New Scene</td></tr><tr><td>Random Level Selector</td><td>Loads a random new scene on game start instead of the default scene</td></tr><tr><td>Studio Machine</td><td>Enables you to add custom T# scripts to an asset</td></tr></tbody></table>

#### Mechanics

<table><thead><tr><th width="255">Logic Template</th><th>Description</th></tr></thead><tbody><tr><td><a href="../logic-templates/mechanics/collectable.md">Collectable</a></td><td>Enables an object to be collected by the player and update the game score. Used in Power-ups. </td></tr><tr><td><a href="../logic-templates/mechanics/teleport-player.md">Teleport Player</a></td><td>Instantly spawns the Player in a new specified position</td></tr><tr><td><a href="../logic-templates/mechanics/jump-pad.md">Jump pad</a></td><td>Creates a jump enhancement for the player upon contact</td></tr><tr><td><a href="../logic-templates/mechanics/carryable.md">Carryable</a></td><td>Enables an Asset to be carried by the Player. The Asset will now move with the Player</td></tr><tr><td><a href="../logic-templates/mechanics/carryable.md">Deposit</a></td><td>Enables the Player to transfer the Carriable Asset and deposit it to a new Asset which is a storage</td></tr><tr><td>Modify Carryable</td><td>Modifies the number of carryables you have</td></tr><tr><td><a href="../logic-templates/mechanics/kill-player.md">Kill Player</a></td><td>Respawns the player to the start of the level</td></tr><tr><td>Hinge Joint</td><td>Enables assets to rotate about a defined hinge like a dore</td></tr><tr><td>Explosive Force</td><td>Applies a force / impulse on a radius</td></tr><tr><td>Add Force</td><td>Applies a force on an object and allows it to follow physics </td></tr><tr><td>Treadmill</td><td>Enables treadmill-like motion on contact</td></tr><tr><td>Multi Point Move</td><td>Shifts the Asset from its starting spot through a path of straight or curved points as needed.</td></tr><tr><td>Attach Object</td><td>Parents an object to another object</td></tr></tbody></table>

#### Actions

<table><thead><tr><th width="260">Logic Template</th><th>Description</th></tr></thead><tbody><tr><td><a href="../logic-templates/actions/destroy.md">Destroy</a></td><td>Destroys the Asset from the scene</td></tr><tr><td>Set Position</td><td>Changes the Asset's position</td></tr><tr><td>Advance Instantiate</td><td></td></tr><tr><td><a href="../logic-templates/actions/grow-shrink.md">Grow / Shrink</a></td><td>Increases or decreases the size of the Asset</td></tr><tr><td><a href="../logic-templates/actions/move.md">Move</a></td><td>Moves the Asset in a straight line path to a specified new position from its starting point.</td></tr><tr><td><a href="../logic-templates/actions/rotate.md">Rotate</a></td><td>Rotates the Asset about a chosen axis</td></tr><tr><td><a href="../logic-templates/actions/move-to-player.md">Move To Player</a></td><td>Moves the Asset to the Player</td></tr><tr><td><a href="../logic-templates/actions/rotate-oscillate.md">Rotate Oscillate </a></td><td>Oscilates the Asset about a specified axis within a specified rotation about the initial position</td></tr><tr><td><a href="broken-reference">Basic Instantiate</a></td><td></td></tr><tr><td>Bump</td><td>Bounce back when you run into it</td></tr><tr><td>Destroy Persistently</td><td>Destroys objects </td></tr></tbody></table>

#### Conditionals

<table><thead><tr><th width="262">Logic Template</th><th>Description</th></tr></thead><tbody><tr><td><a href="../logic-templates/conditionals/switch.md">Switch</a></td><td></td></tr><tr><td><a href="../logic-templates/conditionals/or-gate.md">Or Gate</a></td><td>Acts as a gate that sends out a broadcast signal only after any one of the  required conditions are met. These conditions are broadcast signals from various sources. </td></tr><tr><td><a href="../logic-templates/conditionals/and-gate.md">And Gate</a></td><td>Acts as a gate that sends out a broadcast signal only after all required conditions are met. These conditions are broadcast signals from various sources. It won't activate until every condition is satisfied.</td></tr><tr><td><a href="../logic-templates/conditionals/tick.md">Tick</a></td><td>Generates a broadcast at a pre-defined time or time-intervals</td></tr><tr><td>Random Broadcast</td><td>Generates a broadcast randomly from a pre-specified list of broadcasts</td></tr></tbody></table>

#### Triggers

<table><thead><tr><th width="262">Logic Template</th><th>Description</th></tr></thead><tbody><tr><td><a href="../logic-templates/triggers/collide.md">Collide</a></td><td>Uses contact of collider of the player as a trigger and allows you to generate a broadcast</td></tr><tr><td><a href="../logic-templates/triggers/click.md">Click</a></td><td>Uses mouse click as a trigger and allows you to generate broadcast</td></tr><tr><td><a href="../logic-templates/triggers/delay.md">Delay</a></td><td>Introduces a delay of a specified time</td></tr></tbody></table>

#### Effects

<table><thead><tr><th width="263">Logic Template</th><th>Description</th></tr></thead><tbody><tr><td><a href="../logic-templates/effects/stop-rotate.md">Stop Rotate</a></td><td>Stops Rotation </td></tr><tr><td><a href="../logic-templates/effects/showui/">ShowUI</a></td><td>Displays a UI on the screen</td></tr><tr><td>Stop Animation</td><td>Stops Animation </td></tr><tr><td>Play Player's Animation</td><td>Plays animation of the player</td></tr></tbody></table>

#### PlayerStats

<table><thead><tr><th width="262">Logic Template</th><th>Description</th></tr></thead><tbody><tr><td><a href="../logic-templates/playerstats/update-score.md">Update Score</a></td><td>Updates a specific score group to a new specified value</td></tr><tr><td><a href="../logic-templates/playerstats/reset-score.md">Reset Score</a></td><td>Resets the specified score group to zero</td></tr><tr><td><a href="../logic-templates/playerstats/increase-player-hp.md">Increase HP</a></td><td>Increases the player Health value by the specific amount</td></tr><tr><td><a href="../logic-templates/playerstats/decrease-player-hp.md">Damage HP</a></td><td>Decreases the player Health value by a specific amount</td></tr><tr><td><a href="../logic-templates/playerstats/reset-player-health.md">Reset Health</a></td><td>Resets the player Health value to zero</td></tr><tr><td><a href="../logic-templates/playerstats/level-up.md">Level Up</a></td><td>Guides the Level Mapper on how to increase a property's level to the next tier.</td></tr><tr><td><a href="../logic-templates/playerstats/update-magnet.md">Change Magnet Range</a></td><td>Changes the magnet range for the player's collection</td></tr><tr><td><a href="../logic-templates/playerstats/stop-player-movement.md">Toggle Player Movement</a></td><td>Stops or starts the player movements</td></tr><tr><td>Change Player Speed</td><td>Changes the speed of movement of the player</td></tr></tbody></table>

#### Simulation&#x20;

<table><thead><tr><th width="260">Logic Template</th><th>Description</th></tr></thead><tbody><tr><td><a href="../logic-templates/simulator-templates/storage-input.md">Input Storage</a></td><td></td></tr><tr><td><a href="../logic-templates/simulator-templates/output-generator.md">Output / Generator</a></td><td></td></tr><tr><td><a href="../logic-templates/simulator-templates/helper.md">Helper AI</a></td><td></td></tr><tr><td>Checkout Counter</td><td></td></tr><tr><td><a href="../logic-templates/simulator-templates/self-service-customer.md">Self Serving Customer</a></td><td></td></tr><tr><td>Customer Manager</td><td></td></tr></tbody></table>



## Hybrid Approach - Templates + Coding

Logic Templates are useful for both beginners and experienced developers. For beginners,  they reduce the need for extensive coding knowledge. For senior developers, they eliminate the need to write code from scratch for simple game interactions and save time and effort.

The limitation of Logic Templates is the inflexibility in customizing interactions, as only exposed properties are editable from the editor. We address this by providing wrappers for Logic Templates, customizable via T-Sharp code. These wrappers expose all editable properties to the developer, allowing for more complex interactions than the editor interface permits.

You can read more about how to access the Logic Templates through T-Sharp code in the documentation for [Logic Template Wrappers](../coding-using-t/t-logic-template-wrappers.md).&#x20;


# Configuring the Player

At the heart of every Terra game is the "Player" block. This is the visual character that represents users in the game. Here are the different actions you can perform to configure your player in Terra Studio:&#x20;

## Finding and Selecting the Player

You can select the player by clicking on the player's avatar that is visible in the editor mode. If you are unable to find the player, you can follow these steps:&#x20;

* Click on "Layers" in the Quick Access Menu on the left&#x20;
* Locate and Click on "Player".&#x20;
* Press the F button&#x20;

You will notice that the Player has a default child element TopDownPlayer  which in turn has two more children - ModelRoot and CameraRoot

## Editing Player Characteristics through the Editor Interface

Once you find and select the player in the editor,  the Inspector Panel on the right displays a list of customisable Player Properties. A list of these customisation actions are given below:&#x20;

### Transforming Initial Player Configurations

To do this, you need to select the topmost parent  element in the Layers , named Player.&#x20;

You will notice that can do three basic transformations of the player's initial configuration- `Move` , `Rotate` and `Scale`. When an object is selected 3 handles will appear around it, each representing an axis along which you can manipulate the object. Alternatively, you can also manually change the values in the Inspector panel to get the exact initial configuration of the player you want.&#x20;

### Selecting a Gameplay Controller

Gameplay Controller in the context of mobile or tablet gaming is a system that interprets the player's input on the touchscreen into actions and movements within the game.&#x20;

To change the player controller,  you need to select the topmost parent element in the Layers , named Player.&#x20;

When you select Player, you will see a dropdown on the inspector panel named Controller which shows the TopDown controller by default.&#x20;

**The TopDownController** Offers a third-person perspective without panning, this controller enables movement in all directions, allowing players to navigate their character in a figure-eight pattern. This type of controller is designed to enhance spatial awareness and maneuvering within the game environment, providing a comprehensive view of the surrounding area to facilitate exploration and strategy.

There are also other controlles which are currently hidden.&#x20;

* **RunForwardControllerNonAuto:** This controller requires the player to actively engage with the game by touching the screen to move the character forward. The character stops as soon as the touch is removed. Lateral movements to the left or right are controlled by swiping in the respective direction. This mode does not allow for backward movement, focusing entirely on forward progression and sidestepping.
* **RunForwardControllerAuto:** Similar in concept to the RunForwardControllerNonAuto but with a continuous forward movement mechanic. The player's character automatically moves forward, eliminating the need to constantly touch the screen for movement. Swipes to the left or right enable gradual lateral movement, diverging from instantaneous lane switches to a more fluid transition. This ensures a gameplay experience that requires strategic planning for movement while on the go.

### Editing Player Motion Properties

You can alter how players move through the game space. To edit these properties, you need to select the TopDown Player element (child of the Player element). Once you select it, you can by tweak these properties:

* **Lock to Look Sideways**: Toggle button to lock or unlock sideways view.
* **Scale**: Adjust the player's size (1 = Default).
* **Gravity**: Numerical field to set gravity strength. Higher values make jumps shorter and falls faster, affecting game difficulty.
* **Jump Height**: Set the maximum height for a player's jump. This influences gameplay difficulty and accessibility.
* **Jump Lock**: Toggle to disable jumping via a controller. Useful for creating specific challenges or controlling movement in certain areas.
* **Max Speed**: Define the player's maximum achievable speed.

### Editing Player Animation

The Player's animation can be edited by selecting the `ModelRoot` element under the `TopDownPlayer` element in Layers. The following animations can be edited by choosing from a list of pre-existing animations:

* Idle&#x20;
* Forward Running
* Back Waling
* Walking Forward
* Walk to Right
* Walk Left
* On Jump Start
* While in Air
* On Jump End
* Bump from back
* Bump from front
* Bump from left
* Bump from right

### Editing Player Camera Controls&#x20;

Terra Studio allows creators to edit the following camera control parameters during game play and define how users experience their game visually. You can change this by  selecting the Camera`Root` element under the `TopDownPlayer` element in Layers.

* **Camera Arc X Rot**: A numerical field through which you can define the camera's tilt, allowing for vertical adjustments. Players can aim upwards or downwards, enhancing interactions with objects or enemies located above or below.
* **Spherical Camera Positioning**:
  * **Camera Arc X**: Manages the camera's horizontal positioning, facilitating left-right movements around a focal point.
  * **Camera Arc Y**: Governs the camera's vertical placement for up-down movements, enabling varied angles and perspectives on the game environment.
* **Field of View (FoV) / Size**: A numerical field through which you can specify the visible game world area. A narrow FoV brings the world closer, ideal for precision tasks like sniping, while a wide FoV expands the view for exploratory gameplay, although excessive width can lead to edge distortion.
* **Camera Distance**: A numerical field through which you can adjusting the camera's proximity to focus points or characters, influencing the player's depth perception and detail awareness. Closer settings heighten immersion, whereas greater distances offer expansive views of the surroundings.
* **Camera Type**: Terra Studio supports both **perspective** and **orthographic** cameras, with each type significantly affecting how players perceive and navigate the game world.




# Setting up Game Systems

Game System blocks are systems which affect the overall game and not just individual Assets. Unlike Assets , SFX, Behaviors and Particles which are clearly visible or perceivable, Game systems run in the background but significantly influence the entire gameplay experience. All Game Systems are accessible by clicking on the Essentials button in the Quick Access Menu. The Builder Panel then shows a list of all Game systems.&#x20;

Some game systems that are present in Terra Studio are listed below:&#x20;

## Game Timer

The timer is a critical system that manages the time-related aspects within the game - particular useful in games involving countdowns or time-limited challenges.&#x20;

### Adding a Game Timer

To add a game timer, follow these steps:&#x20;

* Select the joystick icon in the Main Tool bar&#x20;
* Click on Game Timer

You can now see the Game Timer's properties in the Inspector Panel on the right.&#x20;

### Configuring the Game Timer

You can configure the following properties of the game timer in the Inspector Panel:&#x20;

* **Duration Input:** Enter the time in seconds for how long the timer should run.
* **Timer Type Dropdown:** Choose between counting up towards a target time (Count Up) or counting down from a set time (Count Down)
* **Generate Game Signal on Completion:** Generate either a Game Win signal, a Game Lose signal or a Custom Broadcast Signal once the timer is complete.&#x20;
* **Generate Game Signal at a pre-set time:** You need to do the following :
  1. Choose the "Broadcast Type" under Advanced Options and select "At."
  2. To generate the Game Signal, please input the time in seconds. For example, input "35" for the signal to occur at the 35th second.
  3. Choose your broadcast signal: "Game Win," "Game Lose," or a Custom signal.
* **Generate Game Signal at a pre-set frequency:** You need to do the following :
  1. Choose the "Broadcast Type" under Advanced Options and select "Every."
  2. Enter the number of seconds for the repeat interval of the broadcast in the Value Field. For example, for a repeat every 5 seconds, enter 5
  3. Choose your broadcast signal: "Game Win," "Game Lose," or a Custom signal.
* **Show UI Toggle:** Choose to display the timer on-screen or keep it running silently in the background.

## Score

The Score system tracks how players perform in a game, showing their competition level and progress. Every game automatically includes a primary score group called the Main Score\_GameScore. This group becomes active when you use certain game behaviors to change scores.

### Behavior blocks that enable you to update scores

The value of scores in score groups can be altered only by using these these behaviors:

* **Collectable Behavior**: Changing score on picking up items.
* **Update Score Behavior**: To change the score.
* **Reset Score Behavior**: Resets the score to zero.
* **Carriable Behavior**: Using score as a currency for carrying a certain object
* **Deposit Behavior**: Using score to place items in a specified location.

### Creating New Score Groups

You can create extra score groups to track different achievements. For example, if your game includes two types of items to collect, you can set up a separate score group for each type for independent tracking.

### Updating Score Groups

Once you have added one of the five mentioned behaviors, you'll find a "Group" option in the editable properties of the behavior. Here, you can either select Main to update the "Main Score\_GameScore" or create a new custom score group by selecting Custom.

After this you must also decide how much to change the score when the event starts. You can pick any integer for the change.&#x20;

### Configuring Score Groups

You can further configure Score Groups by selecting Essentials from the Quick Access Menu and clicking on the relevant score group you want to customize. Here are the options available

* **ShowUI Toggle Button**: Shows the score on the game screen when this is turned on.
* **UI Prefab Dropdown**: This option lets you choose from a dropdown menu the UI templates where ShowUI will display the score. These templates are predetermined.
* **Persistent Toggle**: Allows you to keep the same score group total when moving from one level to the next. If not chosen, the score group starts over at zero with each new level.
* **Save Best Score Toggle**: When selected, this saves the player's highest score.
* **Show Best ScoreUI Toggle**: When you turn on the "Save Best Score" option, it displays your highest score on the game screen.
* **BestScore UI PreFab Dropdown**: This lets you choose the UI templates that should display the highest score in ShowUI.

## Health

The Health system is a background system that tracks the player health. There are only three behavior blocks that can affect player health - the Increase Player Health, the Decrease Player Health Block and the Reset Player Health Block. By default, the player health is set to a value of 100. When the player health becomes zero, the player is respawned to the last checkpoint in the game.&#x20;

### Configuring the Health System

To configure the Health System, click on Essentials in the Quick Access Menu and select PlayerHealth. You can then configure the following properties of the Health system:

* **Auto Heal Rate**: Turn on Auto Heal and choose how fast the Health should go up every second.
* **Generate a Signal when Player Health becomes zero**: You can create a signal for winning a game, losing a game, or a custom message.

### Game Progress

The Game Progress System tracks the player's advancement in the game according to predefined progress points. It provides players with a sense of achievement and progression as they play. Multiple progress points can be added through the inspector panel, allowing for greater customization and flexibility in the game's structure.

#### How to add game progress system?

1. From the main toolbar at the top of the editor screen, select "GameProgress" to add the game system to the Essentials tab.
2. In the builder menu on the left side of the screen, navigate to the "Essential" tab.
3. Find the "GameProgress" system in the builder panel.
4. Click on "GameProgress" to open the inspector panel.
5. In the inspector panel, you can customize the parameters according to your needs and preferences.

<table><thead><tr><th width="318">Parameters</th><th>Description</th></tr></thead><tbody><tr><td>Progress start</td><td>This parameter helps you define the point the game progress will be tracked.<br>Game starts - At the start of the game<br>Broadcast Listened -Starts tracking the progress when it listens to a broadcast from another object </td></tr><tr><td>Progress points </td><td>List of diffrent milestones in the game</td></tr><tr><td>Persistent</td><td>Game progress came be made persistent by checking the checkbox </td></tr><tr><td>BroadCast at points </td><td>Broadcast can be trigger when player reaches a paticular milestone </td></tr><tr><td>BroadCast On Completion </td><td>Broadcast can be triggered when player reaches the fine milestone.</td></tr></tbody></table>

### Level Mapper

In game development, leveling up is a core feature that not only marks progression but also enriches the player's experience by offering tangible rewards and new challenges. The Level Mapper game system is designed for customizing the upgrade paths of objects within a game. This can include example use-cases like:

* **Weapon evolution**: Weapons can evolve or be upgraded as players collect certain materials or reach particular benchmarks&#x20;
* **Building upgrades**:  to unlock new features or improve their efficiency (upgrading a farm may increase food production rates or a barracks might allow for the training of more advanced units.)
* **Character Progression:** Accumulating enough XP results in the character gaining a level, which might increase the character's stats (like health, strength, agility) and unlock new abilities or skills.

By utilizing the Level Mapper, developers can set clear, trackable goals for players, encouraging engagement and offering rewarding gameplay experiences as they watch their in-game assets grow and evolve.\
The [level-up](https://app.gitbook.com/o/qrOp5exMLmnPZxfhxQgu/s/Gd8RR9TPbiGza2LHqkh7/\~/changes/87/overview/building-blocks-of-a-terra-game/configuring-behaviors/level-up) behavior can be utilized to adjust the progression paths of objects based on the Level Mapper system.

#### How to add Level mapper?

1. From the main toolbar at the top of the editor screen, select "LevelUpgrader" to add the game system to the Essentials tab.
2. In the builder menu on the left side of the screen, navigate to the "Essential" tab.
3. Find the "LevelMapper" system in the builder panel.
4. Click on "LevelMapper" to open the inspector panel.
5. In the inspector panel, you can customize the parameters according to your needs and preferences.

<table><thead><tr><th width="257">Parameter</th><th>Description</th></tr></thead><tbody><tr><td>Group</td><td>custom name allows the game to keep track of the variables that helps level up the game.<br>steps:<br>1. Click on custom option<br>2. Name the variable in the field added below.</td></tr><tr><td>Cost Type</td><td>The parameter that helps achieve the next level <br>There are two options available:<br>1. Resource (Game Score)<br>2. Carryable <br>select any one based on the game requirement.</td></tr><tr><td>Resource Tag</td><td>This is the parameter whose value will be affected once we achieve level up.</td></tr><tr><td>Value</td><td>Update in the property of the group name after you achieve level upgrade</td></tr><tr><td>Currency</td><td>Cost of upgrading to a new level</td></tr></tbody></table>

6. By following these steps, you will have successfully designed upgrade paths for objects within the game.
7. To use this system to upgrade different in-game objects, utilize the Level Up behavior. Refer to the provided link to learn how to add the "[Level Up](https://app.gitbook.com/o/qrOp5exMLmnPZxfhxQgu/s/Gd8RR9TPbiGza2LHqkh7/\~/changes/87/overview/building-blocks-of-a-terra-game/configuring-behaviors/level-up)" behavior.

### Customer Manger

Customer manager is a game system used to spawn and manage the customer. This is a game system mostly used in the tycoon games.

To add this game system, follow these steps:

1. Navigate to the essentials tab from the builder menu.
2. Click on "Customer Manager".
3. In the Inspector panel, you can customize the below-mentioned parameters according to your requirements:

<table><thead><tr><th width="257">Parameter</th><th>Description</th></tr></thead><tbody><tr><td>Customer Manager When</td><td>This dropdown list allows to specify when new customers will be spawned. It can be triggered either on game start or on any broadcast.</td></tr><tr><td>Broadcast data</td><td>This dropdown can be used to add any broadcast at every customer being spawned.</td></tr><tr><td>Delay between</td><td>This Field can be used to add a delay between spawning of each round of customer.</td></tr><tr><td>Level </td><td>This section is used to adjust the rate at which customers are spawned in progressive manner. you can create multiples levels and define the range of customer spawned for each level.</td></tr><tr><td>Defficulty</td><td>You need to define "X" and "Y' values. the number of customer spawned will lie between these values. once the number of customer spawned reaches the "Max spawn" value, the level will get upgraded and next level block will get executed</td></tr><tr><td>Max spawn</td><td>You can specify here the max number of customer that can be spawned in each level</td></tr></tbody></table>

### Order Generator

Order Generator is a game system responsible for generating order for each customer based on the availabilty of items in the store. This is a game system mostly used in the tycoon games.

To add this game system, follow these steps:

1. Navigate to the essentials tab from the builder menu.
2. Click on "Customer Manager".
3. In the Inspector panel, you can customize the below-mentioned parameters according to your requirements:

<table><thead><tr><th width="257">Parameter</th><th>Description</th></tr></thead><tbody><tr><td>Type </td><td>This dropdown list is used to specify the type of order. It can either be a storage or a service.</td></tr><tr><td>Maximum number in an order</td><td>This field can be used to specify the maximum number of items that an order can have.</td></tr><tr><td>Items </td><td></td></tr><tr><td>Group</td><td></td></tr><tr><td>Cost </td><td></td></tr><tr><td>Data </td><td>This section is used to adjust the number of item per order at each specific level. you can create multiples levels and define the range of items that each order should contain at any specific level.</td></tr><tr><td>Defficulty</td><td>You need to define "X" and "Y' values. the number of items in the order will lie between these values. once the number of items reaches the "Threshold" value, the level will get upgraded and next level block will get executed</td></tr><tr><td>Max spawn</td><td>You can specify here the max number of items that can be added in order at each level.</td></tr></tbody></table>

### Path finder

Path finder is a game system that is used to define the area in which the customer can move. This is a game system mostly used in the tycoon games.

To add this game system, follow these steps:

1. Navigate to the essentials tab from the builder menu.
2. Click on "Customer Manager".
3. In the Inspector panel, you can customize the below-mentioned parameters according to your requirements:

<table><thead><tr><th width="257">Parameter</th><th>Description</th></tr></thead><tbody><tr><td>Path finder UI initializes when</td><td></td></tr><tr><td>Lowest point </td><td>This coordinate is used to define the one of cordinate of the diganol of the rectangular area in which the customers can move.</td></tr><tr><td>Highest point</td><td>This coordinate is used to define the other coordinate of the diganol of the rectangular area in which the customers can move.</td></tr><tr><td> Navmesh accur </td><td></td></tr><tr><td>Obstacle avoiding distance offset </td><td>This field can be used to define the distance that the player would maintain from the obstacle </td></tr><tr><td>Minimum height</td><td>This field is used to define the minimum height below which any structure in the player's path would be considered as obstacle </td></tr><tr><td>Maximum height</td><td>This field is used to define the maximum height below which any structure in the player's path would be considered as obstacle and player needs to avoid. </td></tr><tr><td>POI distance offset </td><td>This field is used to define the distance that player need to maintain from POI in the game.</td></tr><tr><td>Broadcast </td><td>Choose to enter a broadcast that can be used as a trigger for any other behavior. </td></tr></tbody></table>

# Configuring the Game Scene

Once you have the Player configured, you then proceed to set up your interactive world - game scene. There are four types of Game Scene blocks you need to set up to finish setting up your game scene:&#x20;

* **Assets:** 3D elements, items, and structures, that players can see and interact with in the game world.
* **SFX :** Auditory elements and sound effects
* **Particles:** Visual effects like smoke, fire, and magical effects, adding depth and realism to the game's visual presentation.
* **Environment:** This includes the broader setting or backdrop of the game scene, encompassing weather conditions, lighting, and landscape features, which sets the mood and context for the player's adventure.

Here is how you can set up each of the above blocks in your scene:

## Assets

### Viewing and Adding New Assets to the Scene

Terra Studio has a thousands of pre-made assets for creators to use directly in their game without having to bother about creating their assets. Here are the steps you need to follow:

* Click on "Asset" in the Quick Access Menu.&#x20;
* Select the "Library View" in the Asset Panel that shows up. You will be shown a library of all assets and their preview. You can search for your desired asset by&#x20;
  * Typing Keywords in the Asset Search Bar
  * Filtering Assets by theme or category tags
* Once you find your desired asset, drag and drop it into the game workspace.&#x20;

{% hint style="info" %}
:dart:  Currently you cannot import your own assets in the game. However, in an upcoming release cycle, you'll be able to upload your assets directly into the Terra Studio environment, making it easier than ever to personalise your games and bring your unique visions to life.
{% endhint %}

### Editing Asset Properties

Once an Asset is added to the scene, you can click on it and view a list of its editable properties in the Inspector Panel. You can edit the following properties of the asset:&#x20;

#### Editing Asset Initial Configuration

You can adjust the initial position, initial rotation and initial scale of the Asset by changing the values manually in the inspector panel or by adjusting the Configuration Gizmo next to the Asset

#### Editing Asset Appearance

You can edit the asset's visual appearance by editing its material properties:&#x20;

* _Color:_ Pick from the color wheel or set RGB values
* _Emission Color_: Pick from the color wheel or set RGB values
* _Texture_: Select from a list of available textures
* _Metallic_: Specify a numerical value between 0 to 1
* _Smoothness:_ Specify a numerical value between 0 to 1
* _Shader_: Select from a list of available shaders
* _Tiling_: Specify the X and Y tiling

#### Specifying Asset Collider

A Collider defines the physical boundaries of an object for collision detection. Colliders help determine when one object makes contact with another within a virtual space.

For any object in Terra Studio, you select from one of four types of collider shapes from the Inspector Panel dropdown:

* **Capsule:** Wraps the object in a capsule shape. Touching anywhere on the capsule counts as touching the object.
* **Sphere:** Surrounds the object with a spherical barrier. Touching the sphere means you've touched the object.
* **Box:** Encases the object in a box shape. Any contact with the box is like touching the object itself.
* **Mesh:** Follows the exact shape of the object. You have to touch the actual surface of the object to register a touch.

<mark style="color:red;">In addition, there is also an IsTrigger Toggle.</mark>

### Adding Logic Templates to Assets

To add a [Logic Template](configuring-game-logic.md#using-logic-templates) to your asset, follow the instructions on the page below:[Adding Logic Templates to an Asset](configuring-game-logic.md#how-to-add-logic-templates)

## SFX

To infuse your game with more life and interactivity, sound effects (SFX) play a crucial role. Here's how to seamlessly integrate them into your game.

### **Selecting and Adding SFX**

* **Navigate to the Builder Menu:** Start by opening the Quick Access Menu and selecting the `SFX` option. This will reveal a catalog of available sound effects suitable for your game's atmosphere and mechanics.
* **Preview SFX:** Ensure your selected SFX aligns with your vision by using the play button for a quick preview. This step is essential before setting the sound effect in stone.
* **Add Sound Effects:** Spot the `+` icon next to your chosen SFX in the list. Clicking this will automatically add the sound effect into your game's environment.

### **Configuring SFX**&#x20;

Once an SFX is added, it appears in the Layers panel. Here, you can select it to view all its configurable properties in the Inspector Panel. These are the properties you can change in the panel to get the sound effect you want :

* **SoundFx When:** Decide when the sound effect starts playing, either at the beginning of the game or after a specific event.
* **Pause on/Un-Pause on:** This dropdown helps you specify the game events (e.g., Game Start, Game Lose, Game Win) that will pause or resume the SFX playback.
* **Can Loop:** This toggle option for the sound to play continuously in a loop.
* **AudioPitch:** Alter the sound's pitch.
* **Volume of Sound:** Control the sound intensity at the source.
* **Is 3D Audio:** Toggle this to determine if the sound's properties change with distance, mimicking natural sound behavior. Disabling this makes the sound's volume and pitch uniform regardless of the listener's location relative to the source. Once this is active, you can specify
  * **Max Distance:** This helps you set the furthest distance at which the sound can be heard from its source.
  * **Minimum Distance:** Establishes the closest distance to the source needed to hear the sound, applicable when 3D audio is enabled.

## **Particles**

Particles allow you to add moving elements such as fire, beams, aurora lights etc within the game environment.&#x20;

### **Selecting and Adding Particles**

* **Selecting the Particles:** Start by opening the Quick Access Menu and selecting the Particles option. This will reveal a catalog of available particle effects with their preview suitable for your game's atmosphere and mechanics.
* **Adding Particles :**Click on the effect you want and drag and drop it to the desired location in your game.&#x20;

### Customizing Particle Properties

Once you have added a particle effect to the game, select it from the Layers Panel . You will be shown a list of customizable  properties in the Inspector Panel. &#x20;

* **Particle VFX When:** Determines the condition under which the particle effect is activated. It can be triggered by a broadcast event or at the game's start.
* **Pause/Un-Pause on:** This dropdown allows you to select specific game events that will pause or resume the Sound Effects (SFX) playback. Options include events like Game Start, Game Lose, and Game Win.
* **Duration:** Sets the duration for which the particle effect will remain visible.
* **Delay Between:** Defines the delay interval between consecutive appearances of the particle effect.
* **Repeat Forever:** This Toggle, If enabled, the particle Visual Effects (VFX) will repeat continuously throughout the game.
* **Repeat Count:** Specifies the number of times the particle VFX will repeat.

## Game Environment

This feature allows you to modify the visual aspects of the game's environment, providing tools to enhance the aesthetic and mood of your game world. You can alter the following parameters of the skybox by selecting Essentials from the Quick Access Menu and the selecting GlobalRenderSettings in the Quick Access Panel. You will see the following editable parameters in the Inspector Panel.&#x20;

<table><thead><tr><th width="271">Property</th><th>Description</th></tr></thead><tbody><tr><td><mark style="color:blue;"><code>Skybox</code></mark></td><td>Adjusts the game's backdrop to give the illusion of a more expansive space. It's like changing the scenery outside a window to make a room feel bigger.</td></tr><tr><td><mark style="color:blue;"><code>Bloom</code></mark></td><td>Creates a glow effect around bright areas in the game, simulating the way light behaves in the real world. It adds a touch of realism by making lights and reflections seem to spill over their boundaries.</td></tr><tr><td><mark style="color:blue;"><code>Vignette</code></mark></td><td>Applies a shading around the screen's edges, drawing the player's focus to the center. This effect can give your game a more dramatic and cinematic feel, as if you're peering through a lens.</td></tr><tr><td><mark style="color:blue;"><code>Fog</code></mark></td><td><p></p><p>Introduces a misty overlay that can be adjusted for depth and density, perfect for setting a mysterious or eerie atmosphere. It's like adding a thin veil over the game world that can make far-off objects seem obscured and distant.</p><p><br></p></td></tr></tbody></table>

---
description: The high level design of any game
---

# Building Blocks of a Terra Game

Any game in Terra consists of four basic blocks -  Player, Game Scene, Game Logic and Game System.&#x20;

## Player

At the core of any game in Terra lies the "Player" , which is the graphical avatar representing players in the game world. The Player is customisable through a collection of editable features called Player Properties

## Game Scene

Having a player isn't enough for a game. You need a scene where the player can explore and interact. Game Scene blocks let you build this world. Without them, the player would just have a big empty space. There are four main types of Game Scene blocks:

* The "Asset" block - Any 3D object that is part of the game's world.&#x20;
* The "SFX" block - Any sound effect  that is added to the game
* The "Particle" block - Any visual graphical effect simulating anything from fire to rain to enhance the visual appeal and realism of the game
* The "Environment" block**:** This refers to the global settings that affect the overall look of the game space. Includes lighting, camera perspectives, and global shaders that give the game its unique atmosphere.

Each of these blocks is customizable & configurable through an associated set of editable properties.&#x20;

Each game can have multiple scenes.&#x20;

## Game Logic

Simply having a Player block and a Game Scene Object block won't create an engaging game experience. Interactivity is key, and this is where Game Logic plays a pivotal role. They are the essence of gameplay, turning a static scene into an immersive, interactive world. Game Logic is always added to Asset Blocks. That way you can program Asset blocks to follow specific instructions, enabling interactivity in the game in precisely the ways you want.

Integrating Game Logic into your game transforms the game into dynamic, interactive elements. Without Game Logic, you're left with a mere navigation through static scenes. It's the Game Logic that turns these scenes into a captivating game.

## Game System

Creating an engaging game requires more than just setting up Game Logic for individual Asset blocks. It's essential to establish a broader framework that outlines the game's fundamental mechanics and rules. This is achieved through the Game Systems. Unlike Game Logic, which dictates how specific assets react, the Game System influences the entire game's operation.

Game Systems can be divided into two categories:

* **Primitive**: These are the basic systems that handle elementary functions such as timing (e.g., countdowns, time limits), scoring (e.g., points awarded for achievements). They are fundamental to almost all games and provide the necessary structure for more complex systems to build upon.
* **Advanced**: These involve more sophisticated mechanics that can include progression mechanics (e.g., levels, unlocking features) AI behavior and economy systems (e.g., currency, trade)

## Game Signals

Game Signals are a mechanism for different blocks to communicate. Common game signals are Game Win , Game Lose or Custom Broadcast&#x20;

### Game Win

It is the signal generated when the player meets the win condition for a game

### Game Lose

It is the signal generated when the player meets the lose condition for a game

### Custom Broadcast

In Terra Studio, the most crucial tool is a custom broadcast signal. This lets you send a unique alert whenever a specific game condition happens. You can name each custom signal differently.

#### Generating a Broadcast Signal

The Custom Broadcast can be generated by any Game Logic, any SFX, any Particle or any Game System. Each broadcast signal is identified by a unique name that you can give it.&#x20;

#### Listening to a Broadcast Signal

Creating a Custom Broadcast isn't enough on its own. It becomes valuable only when there are broadcast listeners set up to receive it. In Terra Studio, Game Logic, Sound SFX, Particles, and Game Systems can all "listen" for these broadcast signals.

Multiple listeners can all receive and act on the same broadcast signal at the same time.&#x20;

## Summary

Games are built using several types of blocks:

* **Player**: Represents the character avatar you control.
* **Game Scene**: Construct the environment of the game.
* **Game Logic**: Make elements interactive, allowing you to engage with the world.
* **Game Systems**: Define the rules and dynamics that keep the game enjoyable and challenging, such as scoring and difficulty progression.





# How do I download & install Terra Studio?

Terra Studio is currently in closed alpha access.  You can apply on [our website](https://www.letsterra.com/) to get access to our app. Well send you details on how to download Terra Studio.&#x20;

<figure><img src="../.gitbook/assets/image (6) (1).png" alt="" width="563"><figcaption><p>Apply for early access from our website!</p></figcaption></figure>

Join our [Discord server](https://discord.gg/XfrWb3P6) for updates on features.&#x20;


# Getting Started

## How do I get Terra Studio?

Apply for Early Access on [our website](https://www.letsterra.com/), and we'll get in touch with you shortly.

Terra Studio is available in two versions.

* **Browser Version**: You will need a username and password
* Desktop Version: If you prefer working on your Windows Desktop or MacBook, you'll need to download an installable file.

Terra Studio currently does not have a mobile version available on Google Play Store or Apple App Store.

## Minimum system requirements

For Terra Studio to function properly, your machine should have a minimum of 16 GB RAM.

## Creating Your First Game with Terra Studio

* To kickstart your new game, simply click  `+ START FROM SCRATCH` on the homepage. This will prompt a dialog box where you can name your project.&#x20;
* Once you've defined the title, a new workspace will open up, providing you with the platform to unleash your creativity. Let's get those ideas flowing!

<figure><img src="../.gitbook/assets/image (7).png" alt=""><figcaption></figcaption></figure>







# Dashboard

This is the first screen you are shown on logging in and your central hub for managing all your projects in Terra Studio. Here's are the actions you can perform from the Terra Studio Dashboard:&#x20;

### Create a New Game

1. Opt for **Start from Scratch** if you wish to initiate a new project.
2. Enter a desired name for your game and hit **Create Project**.
3. You'll be directed to the Scene Editor  for your new game where you can begin creating your game.

### Continue Editing an Existing Game

1. Click on **In Progress** to see the list of games you've started.
2. Choose the game you want to edit by clicking on it.
3. Choose from one of two options for both the scene and the scripts - `Cloud Save` and `Local Save`.  Choose the option most relevant to you.&#x20;
4. You will be then taken to the Scene Editor for that game

### Delete an Existing Game

1. Select **In Progress** to view your ongoing game projects.
2. Find the game you wish to remove and click on the **Delete** icon beside it.




---
description: Learn about the keyboard shortcuts that our software has
---

# Important Keyboard Shortcuts

## Shortcuts

Below you can find all shortcuts and key commands that make working with Terra Studio easier and quicker

### Camera Controls

| Action                        | Windows                 | Mac                     | Description                                                                           |
| ----------------------------- | ----------------------- | ----------------------- | ------------------------------------------------------------------------------------- |
| `Pan Forward`                 | Right Click + W         | Right Click + W         | Pans the camera forward                                                               |
| `Pan Left`                    | Right Click + A         | Right Click + A         | Pans the camera to the left                                                           |
| `Pan Backward`                | Right Click + S         | Right Click + S         | Pans the camera backward                                                              |
| `Pan Right`                   | Right Click + D         | Right Click + D         | Pans the camera to the right                                                          |
| `Pan Down`                    | Right Click + Q         | Right Click + Q         | Pans the camera downward                                                              |
| `Pan Up`                      | Right Click + E         | Right Click + E         | Pans the camera upward                                                                |
| `Changing Camera Orientation` | Right Click + Mouse     | Right Click + Mouse     | Hold down right mouse button while moving the mouse to change the camera orientation. |
| `Zoom In`                     | Mouse Wheel Scroll Up   | Mouse Wheel Scroll Up   | Scroll the mouse wheel up to zoom in.                                                 |
| `Zoom Out`                    | Mouse Wheel Scroll Down | Mouse Wheel Scroll Down | Scroll the mouse wheel down to zoom out.                                              |

### Selecting and Editing

| Action                   | Windows    | Mac        | Description                                                     |
| ------------------------ | ---------- | ---------- | --------------------------------------------------------------- |
| `Duplicate`              | Ctrl + D   |  + D      | Duplicates an object.                                           |
| `Delete`                 | Ctrl + Del |  + Del    | Deletes an object.                                              |
| `Enable Multi Selection` | LShift     |           | Hold down left shift to add or remove objects from selection.   |
| `Undo`                   | Ctrl + Z   |  + Z      | Undoes the last editing step.                                   |
| `Redo`                   | Ctrl + Y   |  or  + Y | Redoes the last editing step.                                   |
| `Toggle Snap`            | Ctrl + 5   |  or  + 5 | Enable or disable snapping an object to another objects surface |

### Steps to locate the player in the editor:

1. Click on "Layers" in the builder menu.
2. Select "Player"
3. Press "F".

You will then see the player.

# Inspector Panel

The Inspector Panel is a key feature for customizing and tweaking the characteristics of game objects or assets you've selected. It's a one-stop shop for adjusting various attributes, including position, size, orientation, physical behavior, visual materials, among others. This panel is instrumental for meticulous adjustments and personalizing elements in your game's world.

To use it, simply select an object either from the Builder Panel or within the game workspace, and the Inspector Panel will display all the properties you can edit for that particular item.

&#x20;Conveniently situated on the right-hand side of the screen, the Inspector Panel is designed to be easily accessible, allowing for a smooth and efficient workflow as you enhance and refine your game's components.

# Main Toolbar

{% hint style="info" %}
This section is Work in Progress. Expect more details soon.&#x20;
{% endhint %}

This is the `Main Toolbar` that has various functionalities to it. These functionalities range from system properties to publishing the game on Studio. All these have been explained below:

## Primitive Elements

This contains a collection of primitive elements which can be used to customize an asset according to your needs.

A few of the elements are:&#x20;

* Cube
* Cylinder
* Sphere
* Light etc.

## System Properties

The properties are discussed below:

* Game Timer - Adds a timer to the game.
* Checkpoint -  Adds a checkpoint in the game.
* Level Upgrader - Makes your game multilevel.

## Save your Project

Although our Studio autosaves your work locally, it is equally important to save your progress on the cloud.&#x20;

To save your project to the Cloud, Click on the `Save` icon. It's that easy!

## Play

Once you click on `Play`, the scene changes to the `gameplay mode` of your project. You can use this to check if everything is working as per vision.&#x20;

Don't forget to save your game, before going into the game-play mode.

## Publish

Once you hit the Publish button, your project will be sent for review purposes.&#x20;

Once your project passes our standard procedures, it will be live on our app in 2-4 days.




# Camera Controls

You can achieve different views of the scene using the camera control.

There are 6 different orientations provided to the user:

* **`Top`** - This allows you to view and edit the scene from the **top view** of the camera.
* **`Bottom`** - This allows you to view and edit the scene from the **bottom view** of the camera.
* **`Left`** - This allows you to view and edit the scene from the **left view** of the camera.
* **`Right`** - This allows you to view and edit the scene from the **right view** of the camera.
* **`Front`** - This allows you to view and edit the scene from the **front view** of the camera.
* **`Back`** - This allows you to view and edit the scene from the **back view** of the camera.

### Projections Control

You have access to two different projections of the scene:

* **`Perspective Projection`**: This will help you to feel the depth of the elements while considering the distance with respect to the viewer.
* **`Orthographic Projection`**: This maintains the uniform scaling of the elements irrespective of the distance.

### Custom Orientation

To achieve a custom orientation of the camera, you can right-press on your mouse, and move the cursor adjusting to your preferred orientation.




# Scene Editor View

Once you [create a new project](dashboard.md#create-a-new-game) or [open an existing project](dashboard.md#continue-editing-an-existing-game), you will be taken to the editor for the game.&#x20;

### Components of the Scene Editor: &#x20;

<figure><img src="../.gitbook/assets/Screenshot 2024-07-05 at 6.23.27PM.png" alt=""><figcaption></figcaption></figure>

## Builder Menu

The Builder menu is a toolbox containing assets, game settings, and various control tools, equipped with essential elements for game creation. Selecting any option in the Builder Menu opens up the Builder Panel for that option. It features six tabs:&#x20;

* `Asset` - For adding and managing game assets

<div align="left" data-full-width="false">

<figure><img src="../.gitbook/assets/Screenshot 2024-07-05 at 7.29.11PM.png" alt="" width="188"><figcaption></figcaption></figure>

</div>

* `Layers` - Allows for organising & duplicating assets across different layers

<div align="left">

<figure><img src="../.gitbook/assets/Screenshot 2024-07-05 at 7.40.40PM.png" alt="" width="188"><figcaption></figcaption></figure>

</div>

* `Essentials` - Includes properties of the game that are unrelated to the player or objects, such as the game timer, player characteristics etc
* `Particles` - Offers special effects like smoke, fire, or sparkles to enhance visual appeal
* `SFX` - Provides a selection of sound effects to improve the game's auditory experience
* `Scene`- Enables setting up and customising the game's environments and levels
* `Logic` - collection of ready to use behaviour blocks&#x20;
* `Script` - collection of scripts to manipulate different game elements&#x20;

## [Main Toolbar](main-toolbar.md)

Situated at the top of the workspace, the Main Toolbar is a versatile collection of tools. It facilitates the transition between design and play, offering functionalities for both editing your game and preparing it for publication.

Whether you're fine-tuning the gameplay mechanics or ready to share your creation with the world, the Main Toolbar contains the necessary tools to progress your game from concept to playable reality.

## [Inspector Panel](inspector-panel.md)

The Inspector Panel is essential for customizing the properties of your game's elements. As you select different objects, the panel dynamically updates to display and allow edits to their unique attributes.

{% hint style="info" %}
**Practical Tip**: Use the Inspector Panel to adjust the advanced properties of game elements, such as size, color, or behavior, tailoring each detail to fit your vision perfectly.
{% endhint %}

## [Camera Panel](camera-controls.md)

Offering various scene perspectives, the Camera Panel allows you to view your game from multiple angles. This is crucial for ensuring your game looks and plays well from every viewpoint.

## Support Chat

Direct access to the Terra Team is available via the Support Chat. Here, you can ask technical questions and receive guidance, ensuring smooth progress in your game development journey.

Simply type your query into the chat, and a Terra Team member will provide you with the assistance you need.

# Builder Menu & Builder Panel

## Builder Menu

This menu (also called the Quick Access Menu) is found on the leftmost side of your screen, equipped with all the necessary elements for game creation. Once you select any category from the Builder Menu, the Builder Panel displays details and actions relevant to the selected item. For instance, selecting <mark style="color:blue;">`Asset`</mark> displays a list of selectable assets with relevant filters in the Builder Panel.&#x20;

The Builder Menu features eight tabs:

### Assets

This tab is meant foradding and managing game assets. Clicking this tab opens the Terra Asset Library with over 150,000 3D assets. Hover over an asset to see its name and polygon count. Use the search bar at the top to find a specific asset by name.

### Layers

This lists all Assets, Particles, and SFX added to the scene in a hierarchical format. The Layers tab includes the Player, Ground, and Light by default. It allows organizing and duplicating assets across different layers.

### Essentials

Features characteristics of the game environment, such as the game timer.

### Particles

Offers special effects like smoke, fire, or sparkles to enhance visual appeal. Clicking this tab shows a library of all available Particle Effects (VFX). You can preview and search for specific VFX.

### SFX

Provides a selection of sound effects to improve the game's auditory experience. Clicking this tab shows a library of all available Sound Effects (SFX). You can preview any sound effect by clicking on the play button and also search for a specific SFX in the search bar.

### Scene

Enables setting up and customising the game's environments and levels. Clicking on this shows a list of all available scenes and environments. You can perform the following actions in the Scene Tab:&#x20;

#### Adding a New Scene

Click on the + button You will be prompted to name the new scene. Enter a name and click OK. Your new scene is now created

### Logic

Clicking this displays a list of available logic templates to drag and drop onto an asset.&#x20;

### Scripts

Clicking this displays a list of all scripts added to objects in the scene. Use the + button in this tab to add a new script.






# Scene Panel

{% hint style="info" %}
This section is a Work in Progress. Expect more details soon.&#x20;
{% endhint %}

The Scene Panel enables users to create and manage multiple scenes in a game project, facilitating organization and seamless transitions. It streamlines the process of creating new scenes, each serving as modular components for different aspects of the game, optimizing performance and enhancing development efficiency.

Once you click on `Scene` in the `Builder Menu`, the `Scene Builder panel` shows all the `Scenes` in that project.

## Add a new Scene&#x20;

* To add a new scene to the project, click on `Scene` in the Builder Menu, the Builder panel opens up.
* On the **top right of the builder panel**, click on `Add New Scene`.&#x20;
* You can define the name of the scene in the pop-up box.
* Clicking on Create button will create a new scene and you can **view** it in the builder panel.

## Switch to different scenes

To switch between multiple scenes, click on the scene from the builder panel and it will switch to that particular scene.

When you switch between scenes, our Studio **auto-saves** your current work!

## Copy a scene

To duplicate any scene, use the copy symbol present at the right of the scene name in the Builder Panel. You will have to rename the copied scene just like how you create a new scene.

\

# Layers

The Layers section provides a structured view of all game components.&#x20;

Selecting "Layers" from the Builder Menu opens the Layers Builder Panel, which displays a comprehensive list of all Assets, Particles, Primitive Elements, and SFX included in your game. This feature helps you monitor and manage every element within the scene efficiently.

## Duplicating an Element

Find the copy symbol next to the element's name in the Layers Builder Panel to duplicate it. The newly created duplicate will have "(Clone)" appended to the original name, making it easy to identify.

## Deleting an Element

To remove an element, simply select it in the Layers Builder Panel and press the Delete key. This action will permanently erase the selected element from your scene, helping you tidy up and organize your game elements as needed.\

# Essentials

Essentials in Terra Studio refer to the core system properties that are essential to the game's functionality and overall experience, but not tied to any specific object or player. These are the overarching settings that affect the game environment and how the player interacts with and progresses through the game.

Some of the Essentials available in Terra Studio are:

* **Global Render Setting**: Customise the visual style of your game's environment with properties like Skybox, Bloom, Vignette, and Fog to create the desired atmosphere.
* **Level Mapper**: Configure the progression system of your game by tracking and managing parameters that determine how players level up and advance.
* **Player Properties**: Access and edit physics-based attributes such as maximum speed, acceleration, and gravity to refine how the player controls feel in the game.
* **In-Game Timer**: Implement a countdown or count-up timer to add time-based challenges or events within your gam

{% hint style="info" %}
**Note**: GlobalRenderSetting and LevelMapper are available by Default. The other essentials need to be manually added depending on your use-case. You can get more details about by clicking on their respective page links
{% endhint %}






# In Game Timer

The In-Game Timer adds a timer to your project.

<table><thead><tr><th width="289">Property</th><th>Description</th></tr></thead><tbody><tr><td><mark style="color:blue;"><code>Timer Type</code></mark></td><td>Defines whether it is a count up or count down timer</td></tr><tr><td><mark style="color:blue;"><code>Timer</code></mark></td><td>Defines the maximum value of the timer</td></tr><tr><td><mark style="color:blue;"><code>Ui Prefab</code></mark></td><td></td></tr><tr><td><mark style="color:blue;"><code>Broadcast</code></mark></td><td>Broadcast is used to define what will happen after the timer ends.</td></tr><tr><td></td><td></td></tr></tbody></table>


# Global Render Setting

This feature allows you to modify the visual aspects of the game's environment, providing tools to enhance the aesthetic and mood of your game world.

<table><thead><tr><th width="271">Property</th><th>Description</th></tr></thead><tbody><tr><td><mark style="color:blue;"><code>Skybox</code></mark></td><td>Adjusts the game's backdrop to give the illusion of a more expansive space. It's like changing the scenery outside a window to make a room feel bigger.</td></tr><tr><td><mark style="color:blue;"><code>Bloom</code></mark></td><td>Creates a glow effect around bright areas in the game, simulating the way light behaves in the real world. It adds a touch of realism by making lights and reflections seem to spill over their boundaries.</td></tr><tr><td><mark style="color:blue;"><code>Vignette</code></mark></td><td>Applies a shading around the screen's edges, drawing the player's focus to the center. This effect can give your game a more dramatic and cinematic feel, as if you're peering through a lens.</td></tr><tr><td><mark style="color:blue;"><code>Fog</code></mark></td><td><p></p><p>Introduces a misty overlay that can be adjusted for depth and density, perfect for setting a mysterious or eerie atmosphere. It's like adding a thin veil over the game world that can make far-off objects seem obscured and distant.</p><p><br></p></td></tr></tbody></table>

# Level Mapper

In game development, leveling up is a core feature that not only marks progression but also enriches the player's experience by offering tangible rewards and new challenges. The Level Mapper is a versatile tool designed for customizing the upgrade paths of objects within your game. This can include example use-cases like:

* **Weapon evolution**: Weapons can evolve or be upgraded as players collect certain materials or reach particular benchmarks&#x20;
* **Building upgrades**:  to unlock new features or improve their efficiency (upgrading a farm may increase food production rates or a barracks might allow for the training of more advanced units.)
* **Character Progression:** Accumulating enough XP results in the character gaining a level, which might increase the character's stats (like health, strength, agility) and unlock new abilities or skills.

By utilizing the Level Mapper, developers can set clear, trackable goals for players, encouraging engagement and offering rewarding gameplay experiences as they watch their in-game assets grow and evolve.

### Parameters

It tracks the following parameters that dictate the conditions under which an object can level up.

<table><thead><tr><th width="257">Parameter</th><th>Description</th></tr></thead><tbody><tr><td><mark style="color:blue;"><code>Group</code></mark></td><td>A custom name that allows the game to kee track of the character that helps level up the game</td></tr><tr><td><mark style="color:blue;"><code>Cost Type</code></mark></td><td>The parameter that helps achieve the next level </td></tr><tr><td><mark style="color:blue;"><code>Resource Tag</code></mark></td><td>The parameter whose value will be affected once we achieve level up</td></tr><tr><td><mark style="color:blue;"><code>Value</code></mark></td><td>Update in the property of the group name after you achieve level upgrade</td></tr><tr><td><mark style="color:blue;"><code>Currency</code></mark></td><td>Cost of upgrading to a new level</td></tr></tbody></table>

###







